{"version":3,"sources":["dragular.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","undefined","options","dragular","containersModel","$eval","./dragularModule",2,"angular","dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","$rootScope","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","$el","element","never","always","emptyObj","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","lookupClass","className","cached","_classesCache","lastIndex","RegExp","addClass","current","test","rmClass","replace","trim","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","domIndexOf","child","parent","Array","prototype","indexOf","children","fireEvent","target","item","source","sourceModel","initialIndex","extra","serviceFn","dispatchEvent","eventType","_mirror","_containersModel","_containers","initialContainers","proceedContainers","containers","nameSpace","initial","push","apply","makeArray","all","startIndex","isArray","slice","removeContainers","applyAsync","changes","forEach","container","index","splice","isContainer","drake","_isContainerModel","isContainerModel","events","remove","documentElement","release","grab","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","destroy","_grabbed","preventDefault","window","event","which","metaKey","ctrlKey","context","canStart","end","start","direction","_sourceItem","parentElement","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","_offsetX","_offsetY","_clientX","_clientY","boundingBox","_offsetXr","_offsetYb","_item","classes","transit","renderMirrorImage","style","drag","dragging","handle","_isContainer","invalid","moves","manualStart","_source","_initialSibling","_currentSibling","copy","cloneNode","scope","$emit","containerIndex","_sourceModel","_initialIndex","invalidTarget","drop","ungrab","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","removeOnSpill","cancel","_targetContainer","_lastElementBehindCursor","_dragOverEvents","isInitialPlacement","dropElm","dropIndex","$applyAsync","targetModel","dropElmModel","removeChild","cleanup","revert","reverts","arguments","revertOnSpill","insertBefore","removeMirrorImage","spillOut","_lastDropTarget","_currentIndex","clientX","clientY","accepted","accepts","immediate","getImmediateChild","reference","getReference","moved","spillOver","over","changed","out","offsetBox","x","y","lockY","_mirrorWidth","lockX","_mirrorHeight","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","getBoundingClientRect","mirror","mirrorContainer","appendChild","body","unselectable","outside","len","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","document","elementFromPoint","defaultClasses","dragOverEventNames","extend","dragOverEvent","createEvent","initEvent","createEventObject","cleanEnviroment"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.directive('dragular', ['dragularService', function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope[iAttrs.dragular] || tryJson(iAttrs.dragular);\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}]);\n\n},{\"./dragularModule\":2}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n\n\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n\n},{\"./dragularDirective.js\":1,\"./dragularService.js\":3}],3:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Module and Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\n/**\n * @ngInject\n */\n\ndragularModule.factory('dragularService', ['$rootScope', function dragula($rootScope) {\n\n  var serviceFn, // function returned as service\n    _classesCache = {}, // classes lookup cache\n    _containersModel = {}, // containers model\n    _containers = {}, // containers managed by the drake\n    _mirror; // mirror image\n\n  serviceFn = function(initialContainers, options) {\n\n    if (arguments.length === 1 && !Array.isArray(initialContainers) && !angular.isElement(initialContainers) && !initialContainers[0]) {\n      // then containers are not provided, only options\n      options = initialContainers;\n      initialContainers = [];\n    }\n\n    var body = document.body,\n      documentElement = document.documentElement,\n      _source, // source container\n      _item, // item being dragged\n      _sourceItem, // item originaly dragged if copy is enabled\n      _sourceModel, // source container model\n      _lastDropTarget = null, // last container item was over\n      _offsetX, // reference x\n      _offsetY, // reference y\n      _offsetXr, // reference x right for boundingBox feature\n      _offsetYb, // reference y bottom for boundingBox feature\n      _clientX, // cache client x, init at grab, update at drag\n      _clientY, // cache client y, init at grab, update at drag\n      _mirrorWidth, // mirror width for boundingBox feature\n      _mirrorHeight, // mirror height for boundingBox feature\n      _initialSibling, // reference sibling when grabbed\n      _currentSibling, // reference sibling now\n      _initialIndex, // reference model index when grabbed\n      _currentIndex, // reference model index now\n      _isContainer, // internal isContainer\n      _isContainerModel, // if o.isContainer is used, model can be provided as well, here it is kept\n      _targetContainer, // droppable container under drag item\n      _dragOverEvents = {}, // drag over events fired on element behind cursor\n      _lastElementBehindCursor, // last element behind cursor\n      _grabbed, // holds mousedown context until first mousemove\n      defaultClasses = {\n        mirror: 'gu-mirror',\n        hide: 'gu-hide',\n        unselectable: 'gu-unselectable',\n        transit: 'gu-transit'\n          // overActive: 'gu-over-active',\n          // overAccepts: 'gu-over-accept',\n          // overDeclines: 'gu-over-decline'\n      },\n      o = { // options\n        dragOverEventNames: ['dragularenter', 'dragularleave', 'dragularrelease'],\n        classes: defaultClasses,\n        containers: false,\n        moves: always,\n        accepts: always,\n        isContainer: never,\n        copy: false,\n        invalid: invalidTarget,\n        revertOnSpill: false,\n        removeOnSpill: false,\n        lockX: false,\n        lockY: false,\n        boundingBox: false,\n        containersModel: false,\n        isContainerModel: emptyObj\n      };\n\n    if (!isElement(o.boundingBox)) {\n      o.boundingBox = null;\n    }\n\n    if (options && options.classes) {\n      angular.extend(defaultClasses, options.classes);\n      angular.extend(options.classes, defaultClasses);\n    }\n\n    angular.extend(o, options);\n\n    if (!o.mirrorContainer) {\n      o.mirrorContainer = document.body;\n    }\n\n    // get initial containers from options, argument or fall back to empty array (containers can be also added later)\n    initialContainers = o.containers || initialContainers || [];\n    initialContainers = makeArray(initialContainers);\n\n    if (o.containersModel) {\n      //                            is 2D array?\n      o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n    }\n\n    function proceedContainers(containers, nameSpace, initial) {\n      if (!containers[nameSpace]) {\n        containers[nameSpace] = [];\n      }\n      Array.prototype.push.apply(containers[nameSpace], initial);\n    }\n\n    // feed containers groups and optionaly shadow it by models\n    if (!o.nameSpace) {\n      o.nameSpace = ['dragularCommon'];\n    }\n    if (!Array.isArray(o.nameSpace)) {\n      o.nameSpace = [o.nameSpace];\n    }\n    o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n      proceedContainers(_containers, nameSpace, initialContainers);\n      if (o.containersModel) {\n        proceedContainers(_containersModel, nameSpace, o.containersModel);\n      }\n    });\n    _isContainer = isContainer;\n\n    //register events\n    events();\n\n    angular.forEach(o.dragOverEventNames, function prepareDragOverEvents(dragOverEvent) {\n      if (document.createEvent) {\n        _dragOverEvents[dragOverEvent] = document.createEvent('HTMLEvents');\n        _dragOverEvents[dragOverEvent].initEvent(dragOverEvent, true, true);\n      } else {\n        _dragOverEvents[dragOverEvent] = document.createEventObject();\n        _dragOverEvents[dragOverEvent].eventType = dragOverEvent;\n      }\n    });\n\n    var drake = {\n      containers: _containers,\n      containersModel: _containersModel,\n      start: manualStart,\n      end: end,\n      cancel: cancel,\n      remove: remove,\n      destroy: destroy,\n      dragging: false\n    };\n\n    return drake;\n\n    // make array from array-like objects or from single element (based on bevacqua/atoa)\n    function makeArray(all, startIndex) {\n      if (Array.isArray(all)) {\n        return all;\n      }\n      if (all.length) { // is array-like\n        return Array.prototype.slice.call(all, startIndex);\n      } else { // is one element\n        return [all];\n      }\n    }\n\n    // add or remove containers - deprecated\n    function removeContainers(all) {\n      $rootScope.applyAsync(function applyDestroyed() {\n        var changes = Array.isArray(all) ? all : makeArray(all);\n        changes.forEach(function forEachContainer(container) {\n          angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n            var index;\n            index = _containers[nameSpace].indexOf(container);\n            _containers[nameSpace].splice(index, 1);\n            if (o.containersModel) {\n              _containersModel[nameSpace].splice(index, 1);\n            }\n          });\n        });\n      });\n    }\n\n    function isContainer(el) {\n      var i = o.nameSpace.length;\n      while (i--) {\n        if (drake.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n          return true;\n        }\n      }\n      if (o.isContainer(el)) {\n        _isContainerModel = o.isContainerModel(el);\n        return true;\n      } else {\n        _isContainerModel = null;\n      }\n      return false;\n    }\n\n    function events(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(documentElement, op, 'mouseup', release);\n\n      initialContainers.forEach(function addMouseDown(container) {\n        regEvent(container, 'on', 'mousedown', grab);\n      });\n    }\n\n    function eventualMovements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(documentElement, op, 'mousemove', startBecauseMouseMoved);\n    }\n\n    function movements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(documentElement, op, 'selectstart', preventGrabbed); // IE8\n      regEvent(documentElement, op, 'click', preventGrabbed);\n      regEvent(documentElement, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n    }\n\n    function destroy() {\n      events(true);\n      removeContainers(initialContainers);\n      release({});\n    }\n\n    function preventGrabbed(e) {\n      if (_grabbed) {\n        e.preventDefault();\n      }\n    }\n\n    function grab(e) {\n      e = e || window.event;\n\n      // filter some odd situations\n      if ((e.which !== 0 && e.which !== 1) || e.metaKey || e.ctrlKey) {\n        return; // we only care about honest-to-god left clicks and touch events\n      }\n\n      var context = canStart(e.target);\n      if (!context) {\n        return;\n      }\n\n      _grabbed = context;\n      eventualMovements();\n      if (e.type === 'mousedown') {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n\n    function startBecauseMouseMoved(e) {\n      eventualMovements(true); // remove mousemove listener\n      movements();\n      end();\n      start(_grabbed);\n\n      // automaticly detect direction of elements if not set in options\n      if (!o.direction) {\n        var parent = _sourceItem.parentElement,\n          parentHeight = parent.offsetHeight,\n          parentWidth = parent.offsetWidth,\n          childHeight = _sourceItem.clientHeight,\n          childWidth = _sourceItem.clientWidth;\n        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n      }\n\n      // get initial coordinates, used to render _mirror for first time\n      var offset = getOffset(_sourceItem);\n      _offsetX = getCoord('pageX', e) - offset.left;\n      _offsetY = getCoord('pageY', e) - offset.top;\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // limiting area of _mirror movement, get initial coordinates\n      if (o.boundingBox) {\n        _offsetXr = getCoord('pageX', e) - offset.right;\n        _offsetYb = getCoord('pageY', e) - offset.bottom;\n      }\n\n      e.preventDefault();\n\n      addClass(_item, o.classes.transit);\n      renderMirrorImage();\n      // initial position\n      _mirror.style.left = _clientX - _offsetX + 'px';\n      _mirror.style.top = _clientY - _offsetY + 'px';\n\n      drag(e);\n    }\n\n\n    function canStart(item) {\n      if (drake.dragging && _mirror) {\n        return; // already dragging\n      }\n\n      var handle = item;\n\n      while (item.parentElement &&\n        !_isContainer(item.parentElement)) {\n        // break loop if user tries to drag item which is considered invalid handle\n        if (o.invalid(item, handle)) {\n          return;\n        }\n        item = item.parentElement; // drag target should be immediate child of container\n        if (!item) {\n          return;\n        }\n      }\n\n      var source = item.parentElement;\n      if (!source ||\n        o.invalid(item, handle) ||\n        !o.moves(item, source, handle)) {\n        return;\n      }\n\n      return {\n        item: item,\n        source: source\n      };\n    }\n\n    function manualStart(item) {\n      var context = canStart(item);\n      if (context) {\n        start(context);\n      }\n    }\n\n    function start(context) {\n      _sourceItem = _item = context.item;\n      _source = context.source;\n      _initialSibling = _currentSibling = nextEl(context.item);\n\n      if (o.copy) {\n        _item = context.item.cloneNode(true);\n        if (o.scope) {\n          o.scope.$emit('cloned', _item, context.item);\n        }\n      }\n\n      // prepare models operations\n      if (o.containersModel) {\n        var containerIndex = initialContainers.indexOf(context.source);\n        _sourceModel = o.containersModel[containerIndex];\n        _initialIndex = domIndexOf(context.item, context.source);\n      }\n\n      drake.dragging = true;\n      if (o.scope) {\n        o.scope.$emit('drag', _sourceItem, _source);\n      }\n\n      return true;\n    }\n\n    function invalidTarget() {\n      return false;\n    }\n\n    function end() {\n      if (!drake.dragging) {\n        return;\n      }\n      drop(_item, _item.parentElement);\n    }\n\n    function ungrab() {\n      _grabbed = false;\n      eventualMovements(true);\n      movements(true);\n    }\n\n    function release(e) {\n      ungrab();\n      if (!drake.dragging) {\n        return;\n      }\n      e = e || window.event;\n\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      var elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY);\n\n      if (dropTarget && (o.copy === false || dropTarget !== _source)) {\n        // found valid target and (is not copy case or target is not initial container)\n        drop(_item, dropTarget);\n      } else if (o.removeOnSpill) {\n        remove();\n      } else {\n        cancel();\n      }\n\n      // after release there is no container hovered\n      _targetContainer = null;\n\n      if (_lastElementBehindCursor) {\n        fireEvent(_lastElementBehindCursor, _dragOverEvents['dragularrelease'], _item, _source, _sourceModel, _initialIndex, elementBehindCursor);\n      }\n\n      if (o.scope) {\n        o.scope.$emit('release', _item, _source);\n      }\n    }\n\n    function drop(item, target) {\n      if (o.scope && isInitialPlacement(target)) {\n        o.scope.$emit('cancel', item, _source, _sourceModel, _initialIndex);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, target, _source, _sourceModel, _initialIndex);\n      }\n      if (o.containersModel && !isInitialPlacement(target)) {\n        var dropElm = item,\n          dropIndex = domIndexOf(dropElm, target);\n        $rootScope.$applyAsync(function applyDrop() {\n          if (target === _source) {\n            _sourceModel.splice(dropIndex, 0, _sourceModel.splice(_initialIndex, 1)[0]);\n          } else {\n            var targetModel,\n              dropElmModel = o.copy ? angular.copy(_sourceModel[_initialIndex]) : _sourceModel[_initialIndex];\n\n            if (!_isContainerModel) {\n              var i = o.nameSpace.length;\n              while (i--) {\n                if (drake.containers[o.nameSpace[i]].indexOf(target) !== -1) {\n                  targetModel = _containersModel[o.nameSpace[i]][drake.containers[o.nameSpace[i]].indexOf(target)];\n                  break;\n                }\n              }\n            } else {\n              targetModel = _isContainerModel;\n            }\n\n            target.removeChild(dropElm); // element must be removed for ngRepeat to apply correctly\n\n            if (!o.copy) {\n              _sourceModel.splice(_initialIndex, 1);\n            }\n            targetModel.splice(dropIndex, 0, dropElmModel);\n          }\n\n          if (item.parentElement) {\n            item.parentElement.removeChild(item);\n          }\n          cleanup();\n        });\n      } else {\n        cleanup();\n      }\n    }\n\n    function remove() {\n      if (!drake.dragging) {\n        return;\n      }\n      var parent = _item.parentElement;\n\n      if (parent) {\n        parent.removeChild(_item);\n      }\n\n      if (o.containersModel) {\n        $rootScope.$applyAsync(function removeModel() {\n          _sourceModel.splice(_initialIndex, 1);\n          cleanup();\n        });\n      }\n\n      if (o.scope) {\n        o.scope.$emit(o.copy ? 'cancel' : 'remove', _item, parent, _sourceModel, _initialIndex);\n      }\n      if (!o.containersModel) {\n        cleanup();\n      }\n    }\n\n    function cancel(revert) {\n      if (!drake.dragging) {\n        return;\n      }\n      var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n        parent = _item.parentElement;\n\n      var initial = isInitialPlacement(parent);\n      if (initial === false && o.copy === false && reverts) {\n        _source.insertBefore(_item, _initialSibling);\n      }\n      if (o.containersModel && !o.copy && !reverts) {\n        drop(_item, parent);\n      } else if (o.scope) {\n        if (initial || reverts) {\n          o.scope.$emit('cancel', _item, _source);\n        } else {\n          o.scope.$emit('drop', _item, parent, _source);\n        }\n      }\n\n      if (!o.containersModel || o.copy || reverts || initial) {\n        cleanup();\n      }\n    }\n\n    function cleanup() {\n      ungrab();\n      removeMirrorImage();\n\n      if (_item) {\n        rmClass(_item, o.classes.transit);\n      }\n\n      drake.dragging = false;\n\n      if (o.removeOnSpill === true) {\n        spillOut();\n      }\n\n      if (o.scope) {\n        o.scope.$emit('out', _item, _lastDropTarget, _source);\n        o.scope.$emit('dragend', _item);\n      }\n\n      _source = _item = _sourceItem = _initialSibling = _currentSibling = _sourceModel = null;\n      _initialIndex = _currentIndex = _lastDropTarget = _isContainerModel = null;\n    }\n\n    // is item currently placed in original container and original position?\n    function isInitialPlacement(target, s) {\n      var sibling = s || (_mirror ? _currentSibling : nextEl(_item));\n      return target === _source && sibling === _initialSibling;\n    }\n\n    // find valid drop container\n    function findDropTarget(elementBehindCursor, clientX, clientY) {\n      var target = elementBehindCursor;\n\n      while (target && !accepted()) {\n        target = target.parentElement;\n      }\n      return target;\n\n      function accepted() {\n        var accepts = false;\n\n        if (_isContainer(target)) { // is droppable?\n\n          var immediate = getImmediateChild(target, elementBehindCursor),\n            reference = getReference(target, immediate, clientX, clientY),\n            initial = isInitialPlacement(target, reference);\n\n          accepts = initial || o.accepts(_item, target, _source, reference, _sourceModel, _initialIndex);\n\n          if (_targetContainer !== target) { // used for scroll issue\n            _targetContainer = target;\n          }\n        }\n        return accepts;\n      }\n    }\n\n    function drag(e) {\n      if (!_mirror) {\n        return;\n      }\n      e = e || window.event;\n\n      // update coordinates\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // count mirror coordiates\n      var x = _clientX - _offsetX,\n        y = _clientY - _offsetY,\n        pageX,\n        pageY,\n        offsetBox;\n\n      // fill extra properties if boundingBox is used\n      if (o.boundingBox) {\n        pageX = getCoord('pageX', e);\n        pageY = getCoord('pageY', e);\n        offsetBox = getOffset(o.boundingBox);\n      }\n\n      if (!o.lockY) {\n        if (!o.boundingBox || (pageX > offsetBox.left + _offsetX && pageX < offsetBox.right + _offsetXr)) {\n          _mirror.style.left = x + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageX < offsetBox.left + _offsetX) {\n            _mirror.style.left = _clientX - (pageX - offsetBox.left) + 'px';\n          } else {\n            _mirror.style.left = _clientX - _mirrorWidth - (pageX - offsetBox.right) + 'px';\n          }\n        }\n      }\n      if (!o.lockX) {\n        if (!o.boundingBox || (pageY > offsetBox.top + _offsetY && pageY < offsetBox.bottom + _offsetYb)) {\n          _mirror.style.top = y + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageY < offsetBox.top + _offsetY) {\n            _mirror.style.top = _clientY - (pageY - offsetBox.top) + 'px';\n          } else {\n            _mirror.style.top = _clientY - _mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n          }\n        }\n      }\n\n      var elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY),\n        changed = dropTarget !== _lastDropTarget;\n\n      if (elementBehindCursor !== _lastElementBehindCursor) {\n        fireEvent(elementBehindCursor, _dragOverEvents['dragularenter'], _item, _source, _sourceModel, _initialIndex, !!dropTarget);\n        if (_lastElementBehindCursor) {\n          fireEvent(_lastElementBehindCursor, _dragOverEvents['dragularleave'], _item, _source, _sourceModel, _initialIndex, elementBehindCursor);\n        }\n        _lastElementBehindCursor = elementBehindCursor;\n      }\n\n      if (changed) {\n        out();\n        _lastDropTarget = dropTarget;\n        over();\n      }\n\n      // do not copy in same container\n      if (dropTarget === _source && o.copy) {\n        if (_item.parentElement) {\n          _item.parentElement.removeChild(_item);\n        }\n        return;\n      }\n\n      var reference,\n        immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n      if (immediate !== null) {\n        reference = getReference(dropTarget, immediate, _clientX, _clientY);\n      } else if (o.revertOnSpill === true && !o.copy) {\n        // the case that mirror is not over valid target and reverting is on and copy is off\n        reference = _initialSibling;\n        dropTarget = _source;\n      } else {\n        // the case that mirror is not over valid target and removing is on or copy is on\n        if (o.copy && _item.parentElement !== null) {\n          // remove item or copy of item\n          _item.parentElement.removeChild(_item);\n        }\n        return;\n      }\n      if (reference === null ||\n        reference !== _item &&\n        reference !== nextEl(_item) &&\n        reference !== _currentSibling) {\n        // moving item/copy to new container from previous one\n        _currentSibling = reference;\n\n        dropTarget.insertBefore(_item, reference); // if reference is null item is inserted at the end\n\n        if (o.scope) {\n          o.scope.$emit('shadow', _item, dropTarget);\n        }\n      }\n\n      function moved(type) {\n        if (o.scope) {\n          o.scope.$emit(type, _item, _lastDropTarget, _source);\n        }\n        if (o.removeOnSpill === true) {\n          type === 'over' ? spillOver() : spillOut();\n        }\n      }\n\n      function over() {\n        if (changed) {\n          moved('over');\n        }\n      }\n\n      function out() {\n        if (_lastDropTarget) {\n          moved('out');\n        }\n      }\n    }\n\n    function spillOver() {\n      rmClass(_item, o.classes.hide);\n    }\n\n    function spillOut() {\n      if (drake.dragging) {\n        addClass(_item, o.classes.hide);\n      }\n    }\n\n    function scrollContainer(e) {\n      if (_targetContainer) {\n        var before = _targetContainer.scrollTop;\n        _targetContainer.scrollTop += e.deltaY;\n        // block scroll of the document when container can be scrolled\n        if (before !== _targetContainer.scrollTop) {\n          e.stopPropagation();\n          e.preventDefault();\n        }\n      }\n    }\n\n    function renderMirrorImage() {\n      if (_mirror) {\n        return;\n      }\n      var rect = _sourceItem.getBoundingClientRect();\n      _mirror = _sourceItem.cloneNode(true);\n      _mirrorWidth = rect.width;\n      _mirrorHeight = rect.height;\n      _mirror.style.width = getRectWidth(rect) + 'px';\n      _mirror.style.height = getRectHeight(rect) + 'px';\n      rmClass(_mirror, o.classes.transit);\n      addClass(_mirror, o.classes.mirror);\n      o.mirrorContainer.appendChild(_mirror);\n      regEvent(documentElement, 'on', 'mousemove', drag);\n      addClass(body, o.classes.unselectable);\n      regEvent(_mirror, 'on', 'wheel', scrollContainer);\n      if (o.scope) {\n        o.scope.$emit('cloned', _mirror, _sourceItem);\n      }\n    }\n\n    function removeMirrorImage() {\n      if (_mirror) {\n        rmClass(body, o.classes.unselectable);\n        regEvent(documentElement, 'off', 'mousemove', drag);\n        regEvent(_mirror, 'off', 'wheel', scrollContainer);\n        _mirror.parentElement.removeChild(_mirror);\n        _mirror = null;\n      }\n    }\n\n    function getImmediateChild(dropTarget, target) {\n      var immediate = target;\n      while (immediate !== dropTarget && immediate.parentElement !== dropTarget) {\n        immediate = immediate.parentElement;\n      }\n      if (immediate === documentElement) {\n        return null;\n      }\n      return immediate;\n    }\n\n    function getReference(dropTarget, target, x, y) {\n      var horizontal = o.direction === 'horizontal';\n      var reference = target !== dropTarget ? inside() : outside();\n      return reference;\n\n      function outside() { // slower, but able to figure out any position\n        var len = dropTarget.children.length;\n        var i;\n        var el;\n        var rect;\n        for (i = 0; i < len; i++) {\n          el = dropTarget.children[i];\n          rect = el.getBoundingClientRect();\n          if (horizontal && rect.left > x) {\n            return el;\n          }\n          if (!horizontal && rect.top > y) {\n            return el;\n          }\n        }\n        return null;\n      }\n\n      function inside() { // faster, but only available if dropped inside a child element\n        var rect = target.getBoundingClientRect();\n        if (horizontal) {\n          return resolve(x > rect.left + getRectWidth(rect) / 2);\n        }\n        return resolve(y > rect.top + getRectHeight(rect) / 2);\n      }\n\n      function resolve(after) {\n        return after ? nextEl(target) : target;\n      }\n    }\n\n    function getScroll(scrollProp, offsetProp) {\n      if (typeof window[offsetProp] !== 'undefined') {\n        return window[offsetProp];\n      }\n      if (documentElement.clientHeight) {\n        return documentElement[scrollProp];\n      }\n      return body[scrollProp];\n    }\n\n    function getOffset(el) {\n      var rect = el.getBoundingClientRect(),\n        scrollTop = getScroll('scrollTop', 'pageYOffset'),\n        scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n      return {\n        left: rect.left + scrollLeft,\n        right: rect.right + scrollLeft,\n        top: rect.top + scrollTop,\n        bottom: rect.bottom + scrollTop\n      };\n    }\n\n    function getElementBehindPoint(point, x, y) {\n      var p = point || {},\n        state = p.className,\n        el;\n      p.className += ' ' + o.classes.hide;\n      el = document.elementFromPoint(x, y);\n      p.className = state;\n      return el;\n    }\n  };\n\n  // clean common/shared objects\n  serviceFn.cleanEnviroment = function cleanEnviroment() {\n    _classesCache = {};\n    _containersModel = {};\n    _containers = {};\n    _mirror = undefined;\n  };\n\n  return serviceFn;\n\n\n  // HELPERS FUNCTIONS:\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function emptyObj() {\n    return {};\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = _classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      _classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n    return host[coord];\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e, item, source, sourceModel, initialIndex, extra) {\n    if (!target) {\n      return;\n    }\n    serviceFn.item = item;\n    serviceFn.source = source;\n    serviceFn.sourceModel = sourceModel;\n    serviceFn.initialIndex = initialIndex;\n    serviceFn.extra = extra;\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n}]);\n\n},{\"./dragularModule\":2}]},{},[2]);\n"],"sourceRoot":"/source/"}