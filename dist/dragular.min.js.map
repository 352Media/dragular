{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/dragularDirective.js","dragular.js","src/dragularModule.js","src/dragularService.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","undefined","options","dragular","containersModel","$eval","./dragularModule",2,"angular","dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","$rootScope","$timeout","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","wheel","$el","element","never","always","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","lookupClass","className","cached","_cache","lastIndex","RegExp","addClass","current","test","rmClass","replace","trim","hasClass","indexOf","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","domIndexOf","child","parent","Array","prototype","children","_mirror","containersNameSpaced","containersNameSpacedModel","initialContainers","proceedNameSpaces","_containers","nameSpace","push","apply","makeArray","all","isArray","iAll","newArray","manipulateContainers","changes","forEach","container","containers","console","warn","splice","isContainer","drake","isContainerNameSpaced","hasOwnProperty","events","rem","documentElement","release","grab","destroy","removeContainer","window","event","item","target","which","metaKey","ctrlKey","start","direction","parentElement","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","_item","_offsetX","_offsetY","_clientX","_clientY","boundingBox","_offsetXr","_offsetYb","delay","_renderTimer","renderMirrorAndDrag","preventDefault","_copy","classes","transit","renderMirrorImage","style","drag","handle","dragging","_isContainer","invalid","moves","_itemModel","_sourceModel","end","containerIndex","itemIndex","_initialIndex","_currentIndex","_targetModel","copy","_copyModel","cloneNode","scope","$emit","_source","_initialSibling","_currentSibling","invalidTarget","tagName","drop","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","removeOnSpill","remove","cancel","_targetContainer","dragOverClasses","_lastOverElem","_lastOverClass","isInitialPlacement","cleanup","itemModel","removeChild","revert","reverts","arguments","revertOnSpill","initial","_lastTargetModel","moveInContainersModel","insertBefore","removeMirrorImage","_lastDropTarget","clientX","clientY","accepted","accepts","immediate","getImmediateChild","reference","getReference","_containersModel","overActive","overAccepts","overDeclines","moved","over","changed","out","offsetBox","x","y","lockY","_mirrorWidth","lockX","_mirrorHeight","$applyAsync","referenceIndex","index","scrollContainer","scrollTop","deltaY","stopPropagation","getBoundingClientRect","mirror","mirrorContainer","appendChild","body","unselectable","outside","len","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","hide","document","elementFromPoint","defaultClasses","extend","addContainer"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global angular */\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.directive('dragular', ['dragularService', function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope[iAttrs.dragular] || tryJson(iAttrs.dragular);\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}])\n",null,"/* global angular */\n'use strict';\n\n\n\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n","/* global angular */\n'use strict';\n\n/**\n * dragular Module and Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\n/**\n * @ngInject\n */\n\ndragularModule.factory('dragularService', ['$rootScope', '$timeout', function dragula($rootScope, $timeout) {\n\n  var containersNameSpaced = {}, // name-spaced containers\n    containersNameSpacedModel = {}, // name-spaced containers models\n    _cache = {}, // classes lookup cache\n    _mirror; // mirror image\n\n  return function(initialContainers, options) {\n\n    if (arguments.length === 1 && !Array.isArray(initialContainers) && !angular.isElement(initialContainers) && !initialContainers[0]) {\n      // then containers are not provided, only options\n      options = initialContainers;\n      initialContainers = [];\n    }\n\n    var body = document.body,\n      documentElement = document.documentElement,\n      _source, // source container\n      _item, // item being dragged\n      _sourceModel, // source container model\n      _itemModel, // item-model being dragged\n      _targetModel, // target container model\n      _lastTargetModel, // last target container model\n      _lastDropTarget = null, // last container item was over\n      _offsetX, // reference x\n      _offsetY, // reference y\n      _offsetXr, // reference x right for boundingBox feature\n      _offsetYb, // reference y bottom for boundingBox feature\n      _clientX, // cache client x, init at grab, update at drag\n      _clientY, // cache client y, init at grab, update at drag\n      _mirrorWidth, // mirror width for boundingBox feature\n      _mirrorHeight, // mirror height for boundingBox feature\n      _initialSibling, // reference sibling when grabbed\n      _currentSibling, // reference sibling now\n      _initialIndex, // reference model index when grabbed\n      _currentIndex, // reference model index now\n      _lastOverElem, // last element behind the cursor (dragOverClasses feature)\n      _lastOverClass, // last overClass used (dragOverClasses feature)\n      _copy, // item used for copying\n      _copyModel, // item-model used for copying\n      _containers = {}, // containers managed by the drake\n      _containersModel = {}, // containers model\n      _renderTimer, // timer for setTimeout renderMirrorImage\n      _isContainer, // internal isContainer\n      _targetContainer, // droppable container under drag item\n      defaultClasses = {\n        mirror: 'gu-mirror',\n        hide: 'gu-hide',\n        unselectable: 'gu-unselectable',\n        transit: 'gu-transit',\n        overActive: 'gu-over-active',\n        overAccepts: 'gu-over-accept',\n        overDeclines: 'gu-over-decline'\n      },\n      o = { // options\n        classes: defaultClasses,\n        containers: false,\n        moves: always,\n        accepts: always,\n        isContainer: never,\n        copy: false,\n        delay: false,\n        invalid: invalidTarget,\n        revertOnSpill: false,\n        removeOnSpill: false,\n        dragOverClasses: false,\n        lockX: false,\n        lockY: false,\n        boundingBox: false,\n        containersModel: false\n      };\n\n    if (!isElement(o.boundingBox)) {\n      o.boundingBox = null;\n    }\n\n    if (options && options.classes) {\n      angular.extend(defaultClasses, options.classes);\n      angular.extend(options.classes, defaultClasses);\n    }\n\n    angular.extend(o, options);\n\n    if (o.delay === true) {\n      o.delay = 300;\n    }\n\n    if (o.mirrorContainer === void 0) {\n      o.mirrorContainer = document.body;\n    }\n\n    // get initial containers from options, argument or fall back to empty array (containers can be added later)\n    initialContainers = o.containers || (initialContainers ? makeArray(initialContainers) : []);\n    if (o.containers) {\n      // make array from o.containers\n      initialContainers = makeArray(initialContainers);\n    }\n    if (o.containersModel) {\n      o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n    }\n\n    // feed namespaced containers groups and optionaly shadow it by models\n    if (o.nameSpace) {\n      if (!Array.isArray(o.nameSpace)) {\n        o.nameSpace = [o.nameSpace];\n      }\n\n      function proceedNameSpaces(_containers, containersNameSpaced, nameSpace, initialContainers) {\n        if (!containersNameSpaced[nameSpace]) {\n          containersNameSpaced[nameSpace] = [];\n        }\n        Array.prototype.push.apply(containersNameSpaced[nameSpace], initialContainers);\n        _containers[nameSpace] = containersNameSpaced[nameSpace];\n      }\n      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n        proceedNameSpaces(_containers, containersNameSpaced, nameSpace, initialContainers);\n        if (o.containersModel) {\n          proceedNameSpaces(_containersModel, containersNameSpacedModel, nameSpace, o.containersModel)\n        }\n      });\n      _isContainer = isContainerNameSpaced;\n    } else {\n      // default (not using nameSpaces)\n      _containers = initialContainers;\n      _isContainer = isContainer;\n      if (o.containersModel) {\n        _containersModel = o.containersModel;\n      }\n    }\n\n    //register events\n    events();\n\n    var drake = {\n      addContainer: manipulateContainers('add'),\n      removeContainer: manipulateContainers('remove'),\n      containers: _containers,\n      start: start,\n      end: end,\n      cancel: cancel,\n      remove: remove,\n      destroy: destroy,\n      dragging: false\n    };\n\n    return drake;\n\n    // make array from array-like objects or from single element\n    function makeArray(all) {\n      if (Array.isArray(all)) {\n        return all;\n      }\n      if (all.length) { // is array-like\n        var iAll = all.length,\n          newArray = [];\n        while (iAll) {\n          iAll--;\n          newArray.push(all[iAll]);\n        }\n        return newArray;\n      } else { // is one element\n        return [all];\n      }\n    }\n\n    // add or remove containers - deprecated\n    function manipulateContainers(op) {\n      return function addOrRemove(all) {\n        var changes = Array.isArray(all) ? all : makeArray(all);\n        changes.forEach(function forEachContainer(container) {\n          if (o.nameSpace) {\n            angular.forEach(o.nameSpace, function addRemoveNamespaced(containers, nameSpace) {\n              if (op === 'add') {\n                _containers[nameSpace].push(container);\n                console.warn && console.warn('drake.addContainer is deprecated. please access drake.containers directly, instead');\n              } else {\n                _containers[nameSpace].splice(_containers.indexOf(container), 1);\n                console.warn && console.warn('drake.removeContainer is deprecated. please access drake.containers directly, instead');\n              }\n            });\n          } else {\n            if (op === 'add') {\n              _containers.push(container);\n              console.warn && console.warn('drake.addContainer is deprecated. please access drake.containers directly, instead');\n            } else {\n              _containers.splice(_containers.indexOf(container), 1);\n              console.warn && console.warn('drake.removeContainer is deprecated. please access drake.containers directly, instead');\n            }\n          }\n        });\n      };\n    }\n\n    function isContainer(el) {\n      return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n    }\n\n    function isContainerNameSpaced(el) {\n      var nameSpace;\n      for (nameSpace in drake.containers) {\n        if (drake.containers.hasOwnProperty(nameSpace) && drake.containers[nameSpace].indexOf(el) !== -1) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function events(rem) {\n      var op = rem ? 'off' : 'on';\n      regEvent(documentElement, op, 'mouseup', release);\n\n      initialContainers.forEach(function addMouseDown(container) {\n        regEvent(container, 'on', 'mousedown', grab);\n      });\n    }\n\n    function destroy() {\n      events(true);\n      drake.removeContainer(_containers);\n      release({});\n    }\n\n    function grab(e) {\n      e = e || window.event;\n      var item = e.target;\n\n      // filter some odd situations\n      if ((e.which !== 0 && e.which !== 1) || e.metaKey || e.ctrlKey) {\n        return; // we only care about honest-to-god left clicks and touch events\n      }\n\n      // check if drag can start\n      if (start(item) !== true) {\n        return;\n      }\n\n      // automaticly detect direction of elements if not set in options\n      if (!o.direction) {\n        var parent = item.parentElement,\n          parentHeight = parent.offsetHeight,\n          parentWidth = parent.offsetWidth,\n          childHeight = item.clientHeight,\n          childWidth = item.clientWidth;\n        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n      }\n\n      // get initial coordinates, used to render _mirror for first time\n      var offset = getOffset(_item);\n      _offsetX = getCoord('pageX', e) - offset.left;\n      _offsetY = getCoord('pageY', e) - offset.top;\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // limiting area of _mirror movement, get initial coordinates\n      if (o.boundingBox) {\n        _offsetXr = getCoord('pageX', e) - offset.right;\n        _offsetYb = getCoord('pageY', e) - offset.bottom;\n      }\n\n      // delayed rendering\n      if (typeof o.delay === 'number') {\n        _renderTimer = $timeout(function() {\n          renderMirrorAndDrag(e);\n        }, o.delay);\n      } else {\n        renderMirrorAndDrag(e);\n      }\n\n      e.preventDefault();\n    }\n\n    function renderMirrorAndDrag(e) {\n      addClass(_copy || _item, o.classes.transit);\n      renderMirrorImage();\n      // initial position\n      _mirror.style.left = _clientX - _offsetX + 'px';\n      _mirror.style.top = _clientY - _offsetY + 'px';\n\n      drag(e);\n    }\n\n\n    function start(item) {\n      var handle = item;\n\n      if (drake.dragging && _mirror) {\n        return; // already dragging\n      }\n\n      if (_isContainer(item)) {\n        return; // don't drag container itself\n      }\n\n      while (item.parentElement && !_isContainer(item.parentElement)) {\n        // break loop if user tries to drag item which is considered invalid handle\n        if (o.invalid(item, handle)) {\n          return;\n        }\n        item = item.parentElement; // drag target should be immediate child of container\n        if (!item) {\n          return;\n        }\n      }\n\n      var container = item.parentElement;\n      if (!container) {\n        return;\n      }\n      if (!container || o.invalid(item, handle) || !o.moves(item, container, handle, _itemModel, _sourceModel)) { // is movable\n        return;\n      }\n\n      end();\n\n      // prepare models operations\n      if (o.containersModel) {\n        var containerIndex = initialContainers.indexOf(container),\n          itemIndex = domIndexOf(item, container);\n\n        _initialIndex = _currentIndex = itemIndex;\n        _sourceModel = o.containersModel[containerIndex];\n        _targetModel = _sourceModel;\n        _itemModel = _sourceModel[itemIndex];\n        if (o.copy) {\n          _copyModel = angular.copy(_itemModel);\n        }\n      }\n\n      if (o.copy) {\n        _copy = item.cloneNode(true);\n        if (o.scope) {\n          o.scope.$emit('cloned', _copy, item, _copyModel, _itemModel);\n        }\n      }\n\n      _source = container;\n      _item = item;\n      _initialSibling = _currentSibling = nextEl(item);\n\n      drake.dragging = true;\n      if (o.scope) {\n        o.scope.$emit('drag', _item, _source);\n      }\n\n      return true;\n    }\n\n    function invalidTarget(el) {\n      return el.tagName === 'A' || el.tagName === 'BUTTON';\n    }\n\n    function end() {\n      if (!drake.dragging) {\n        return;\n      }\n      console.log('!!!!! I havent seen this message in any case');\n      var item = _copy || _item;\n      drop(item, item.parentElement);\n    }\n\n    function release(e) {\n      if (!drake.dragging) {\n        return;\n      }\n      e = e || window.event;\n\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      var item = _copy || _item,\n        elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY);\n\n      if (dropTarget && (o.copy === false || dropTarget !== _source)) {\n        // found valid target and (is not copy case or target is not initial container)\n        drop(item, dropTarget);\n      } else if (o.removeOnSpill) {\n        remove();\n      } else {\n        cancel();\n      }\n\n      // after release there is no container hovered\n      _targetContainer = null;\n\n      // remove classes if used\n      if (o.dragOverClasses && _lastOverElem) {\n        rmClass(_lastOverElem, _lastOverClass);\n        _lastOverElem = null;\n      }\n    }\n\n    function drop(item, target) {\n      if (o.scope && isInitialPlacement(target)) {\n        o.scope.$emit('cancel', item, _source, _copyModel || _itemModel, _sourceModel, _targetModel);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, target, _source, _copyModel || _itemModel, _sourceModel, _targetModel);\n      }\n      cleanup();\n    }\n\n    function remove() {\n      if (!drake.dragging) {\n        return;\n      }\n      var item = _copy || _item,\n        parent = item.parentElement;\n\n      if (!o.containersModel) {\n        if (parent) {\n          parent.removeChild(item);\n        }\n      } else {\n        var itemModel = _copyModel || _itemModel;\n        _targetModel.splice(_targetModel.indexOf(itemModel), 1);\n      }\n\n      if (o.scope) {\n        o.scope.$emit(o.copy ? 'cancel' : 'remove', item, parent, itemModel, _sourceModel, _targetModel);\n      }\n      cleanup();\n    }\n\n    function cancel(revert) {\n      if (!drake.dragging) {\n        return;\n      }\n      var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n        item = _copy || _item,\n        parent = item.parentElement;\n\n      if (parent === _source && o.copy) {\n        console.log('!!!!!!!!!!!!!!!!! I think this is never possible because copy cannot be placed into source');\n        if (!o.containersModel) {\n          parent.removeChild(_copy);\n        } else {\n          _targetModel.splice(_targetModel.indexOf(_copyModel), 1, _copyModel);\n        }\n      }\n\n      var initial = isInitialPlacement(parent);\n      if (initial === false && o.copy === false && reverts) {\n        if (!o.containersModel) {\n          _source.insertBefore(item, _initialSibling);\n        } else {\n          _lastTargetModel = _targetModel;\n          _targetModel = _sourceModel;\n          // move back to initial placement\n          moveInContainersModel(_initialIndex);\n        }\n      }\n\n      if (o.scope && (initial || reverts)) {\n        o.scope.$emit('cancel', item, _source);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, parent, _source);\n      }\n\n      cleanup();\n    }\n\n    function cleanup() {\n      var item = _copy || _item;\n      removeMirrorImage();\n\n      if (item) {\n        rmClass(item, o.classes.transit);\n      }\n\n      // cancel timer\n      if (_renderTimer) {\n        $timeout.cancel(_renderTimer);\n      }\n\n      drake.dragging = false;\n\n      if (o.scope) {\n        o.scope.$emit('dragend', item);\n        o.scope.$emit('out', item, _lastDropTarget, _source);\n      }\n\n      _source = _item = _copy = _initialSibling = _currentSibling = _sourceModel = null;\n      _itemModel = _copyModel = _initialIndex = _currentIndex = _renderTimer = _lastDropTarget = null;\n    }\n\n    // is item currently placed in original container and original position?\n    function isInitialPlacement(target, s) {\n      var sibling = s || (_mirror ? _currentSibling : nextEl(_item || _copy));\n      return target === _source && sibling === _initialSibling;\n    }\n\n    // find valid drop container\n    function findDropTarget(elementBehindCursor, clientX, clientY) {\n      var target = elementBehindCursor;\n      while (target && !accepted()) {\n        target = target.parentElement;\n      }\n      return target;\n\n      function accepted() {\n        var accepts = false;\n\n        if (_isContainer(target)) { // is droppable?\n          _targetContainer = target;\n\n          var immediate = getImmediateChild(target, elementBehindCursor),\n            reference = getReference(target, immediate, clientX, clientY),\n            initial = isInitialPlacement(target, reference);\n          accepts = initial ? true : o.accepts(_item, target, _source, reference, _itemModel, _sourceModel);\n\n          if (accepts && o.containersModel) {\n            _lastTargetModel = _targetModel;\n            if (!o.nameSpace) {\n              _targetModel = _containersModel[drake.containers.indexOf(target)];\n            } else {\n              for (var nameSpace in drake.containers) {\n                if (drake.containers.hasOwnProperty(nameSpace) && drake.containers[nameSpace].indexOf(target) !== -1) {\n                  _lastTargetModel = _targetModel;\n                  _targetModel = _containersModel[nameSpace][drake.containers[nameSpace].indexOf(target)];\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // add class if element is enabled for it and it has not already the class\n        if (o.dragOverClasses &&\n          hasClass(target, o.classes.overActive) &&\n          target !== _lastOverElem) {\n\n          if (_lastOverElem) { // clear from previous\n            rmClass(_lastOverElem, _lastOverClass);\n          }\n\n          _lastOverClass = accepts ? o.classes.overAccepts : o.classes.overDeclines;\n          addClass(target, _lastOverClass);\n          _lastOverElem = target;\n        }\n\n        return accepts;\n      }\n    }\n\n    function drag(e) {\n      if (!_mirror) {\n        return;\n      }\n      e = e || window.event;\n\n      // update coordinates\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // count mirror coordiates\n      var x = _clientX - _offsetX,\n        y = _clientY - _offsetY,\n        pageX,\n        pageY,\n        offsetBox;\n\n      // fill extra properties if boundingBox is used\n      if (o.boundingBox) {\n        pageX = getCoord('pageX', e);\n        pageY = getCoord('pageY', e);\n        offsetBox = getOffset(o.boundingBox);\n      }\n\n      if (!o.lockY) {\n        if (!o.boundingBox || (pageX > offsetBox.left + _offsetX && pageX < offsetBox.right + _offsetXr)) {\n          _mirror.style.left = x + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageX < offsetBox.left + _offsetX) {\n            _mirror.style.left = _clientX - (pageX - offsetBox.left) + 'px';\n          } else {\n            _mirror.style.left = _clientX - _mirrorWidth - (pageX - offsetBox.right) + 'px';\n          }\n        }\n      }\n      if (!o.lockX) {\n        if (!o.boundingBox || (pageY > offsetBox.top + _offsetY && pageY < offsetBox.bottom + _offsetYb)) {\n          _mirror.style.top = y + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageY < offsetBox.top + _offsetY) {\n            _mirror.style.top = _clientY - (pageY - offsetBox.top) + 'px';\n          } else {\n            _mirror.style.top = _clientY - _mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n          }\n        }\n      }\n\n      var item = _copy || _item,\n        elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY),\n        changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n\n      if (changed || dropTarget === null) {\n        if (o.scope) {\n          out();\n          _lastDropTarget = dropTarget;\n          over();\n        } else {\n          _lastDropTarget = dropTarget;\n        }\n      }\n\n      // do not copy in same container\n      if (dropTarget === _source && o.copy) {\n        if (!o.containersModel && item.parentElement) {\n          item.parentElement.removeChild(item);\n        } else if (o.containersModel && _lastTargetModel.indexOf(_copyModel) !== -1) {\n          _lastTargetModel.splice(_lastTargetModel.indexOf(_copyModel), 1);\n          $rootScope.$applyAsync();\n        }\n        return;\n      }\n\n      var reference,\n        immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n      // prepare models operations\n      if (o.containersModel) {\n        var referenceIndex;\n      }\n\n      if (immediate !== null) {\n        reference = getReference(dropTarget, immediate, _clientX, _clientY);\n        if (o.containersModel) {\n          if (reference) { // reference is null if drag is over last element\n            referenceIndex = domIndexOf(reference, dropTarget);\n          } else {\n            referenceIndex = null;\n          }\n        }\n      } else if (o.revertOnSpill === true && !o.copy) {\n        // the case that mirror is not over valid target and reverting is on and copy is off\n        reference = _initialSibling;\n        dropTarget = _source;\n\n        // getting model intitial properties into current\n        if (o.containersModel) {\n          referenceIndex = _initialIndex;\n          _lastTargetModel = _targetModel;\n          _targetModel = _sourceModel;\n        }\n      } else {\n        // the case that mirror is not over valid target and removing is on or copy is on\n        if ((o.copy || o.removeOnSpill === true) && item.parentElement !== null) {\n          // remove item or copy of item\n          if (!o.containersModel) {\n            item.parentElement.removeChild(item);\n          } else {\n            _targetModel.splice(referenceIndex, 1);\n            $rootScope.$applyAsync();\n          }\n        }\n        return;\n      }\n      if (reference === null ||\n        reference !== item &&\n        reference !== nextEl(item) &&\n        reference !== _currentSibling) {\n        // moving item/copy to new container from previous one\n        _currentSibling = reference;\n\n        if (!o.containersModel) {\n          dropTarget.insertBefore(item, reference); // if reference is null item is inserted at the end\n        } else {\n          moveInContainersModel(referenceIndex);\n        }\n\n        if (o.scope) {\n          o.scope.$emit('shadow', item, dropTarget);\n        }\n      }\n\n      function moved(type) {\n        o.scope.$emit(type, item, _lastDropTarget, _source);\n      }\n\n      function over() {\n        if (changed) {\n          moved('over');\n        }\n      }\n\n      function out() {\n        if (_lastDropTarget) {\n          moved('out');\n        }\n      }\n    }\n\n    function moveInContainersModel(referenceIndex) {\n      if (_lastTargetModel === _targetModel) {\n        if (referenceIndex === null) {\n          referenceIndex = _targetModel.length;\n        }\n        var index = referenceIndex > _currentIndex ? referenceIndex - 1 : referenceIndex;\n        _targetModel.splice(index, 0, _lastTargetModel.splice(_currentIndex, 1)[0]);\n        _currentIndex = index;\n      } else {\n        if (referenceIndex === null) {\n          referenceIndex = _targetModel.length - 1;\n        }\n        if (!o.copy || _lastTargetModel !== _sourceModel) { // dont remove original from source while copying\n          _lastTargetModel.splice(_currentIndex, 1);\n        }\n        if (!o.copy || _targetModel.indexOf(_copyModel) === -1) { // dont place copy twice in one drag\n          _targetModel.splice(referenceIndex, 0, _copyModel || _itemModel);\n          _currentIndex = referenceIndex;\n        }\n      }\n      $rootScope.$applyAsync();\n    }\n\n    function scrollContainer(e) {\n      if (_targetContainer) {\n        _targetContainer.scrollTop += e.deltaY;\n        e.stopPropagation();\n        e.preventDefault();\n      };\n    }\n\n    function renderMirrorImage() {\n      if (_mirror) {\n        return;\n      }\n      var rect = _item.getBoundingClientRect();\n      _mirror = _item.cloneNode(true);\n      _mirrorWidth = rect.width;\n      _mirrorHeight = rect.height;\n      _mirror.style.width = getRectWidth(rect) + 'px';\n      _mirror.style.height = getRectHeight(rect) + 'px';\n      rmClass(_mirror, o.classes.transit);\n      addClass(_mirror, o.classes.mirror);\n      o.mirrorContainer.appendChild(_mirror);\n      regEvent(documentElement, 'on', 'mousemove', drag);\n      addClass(body, o.classes.unselectable);\n      regEvent(_mirror, 'on', 'wheel', scrollContainer);\n      if (o.scope) {\n        o.scope.$emit('cloned', _mirror, _item);\n      }\n    }\n\n    function removeMirrorImage() {\n      if (_mirror) {\n        rmClass(body, o.classes.unselectable);\n        regEvent(documentElement, 'off', 'mousemove', drag);\n        regEvent(_mirror, 'off', 'wheel', scrollContainer);\n        _mirror.parentElement.removeChild(_mirror);\n        _mirror = null;\n      }\n    }\n\n    function getImmediateChild(dropTarget, target) {\n      var immediate = target;\n      while (immediate !== dropTarget && immediate.parentElement !== dropTarget) {\n        immediate = immediate.parentElement;\n      }\n      if (immediate === documentElement) {\n        return null;\n      }\n      return immediate;\n    }\n\n    function getReference(dropTarget, target, x, y) {\n      var horizontal = o.direction === 'horizontal';\n      var reference = target !== dropTarget ? inside() : outside();\n      return reference;\n\n      function outside() { // slower, but able to figure out any position\n        var len = dropTarget.children.length;\n        var i;\n        var el;\n        var rect;\n        for (i = 0; i < len; i++) {\n          el = dropTarget.children[i];\n          rect = el.getBoundingClientRect();\n          if (horizontal && rect.left > x) {\n            return el;\n          }\n          if (!horizontal && rect.top > y) {\n            return el;\n          }\n        }\n        return null;\n      }\n\n      function inside() { // faster, but only available if dropped inside a child element\n        var rect = target.getBoundingClientRect();\n        if (horizontal) {\n          return resolve(x > rect.left + getRectWidth(rect) / 2);\n        }\n        return resolve(y > rect.top + getRectHeight(rect) / 2);\n      }\n\n      function resolve(after) {\n        return after ? nextEl(target) : target;\n      }\n    }\n\n    function getScroll(scrollProp, offsetProp) {\n      if (typeof window[offsetProp] !== 'undefined') {\n        return window[offsetProp];\n      }\n      if (documentElement.clientHeight) {\n        return documentElement[scrollProp];\n      }\n      return body[scrollProp];\n    }\n\n    function getOffset(el) {\n      var rect = el.getBoundingClientRect(),\n        scrollTop = getScroll('scrollTop', 'pageYOffset'),\n        scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n      return {\n        left: rect.left + scrollLeft,\n        right: rect.right + scrollLeft,\n        top: rect.top + scrollTop,\n        bottom: rect.bottom + scrollTop\n      };\n    }\n\n    function getElementBehindPoint(point, x, y) {\n      if (!x && !y) {\n        return null;\n      }\n      var p = point || {},\n        state = p.className,\n        el;\n      p.className += ' ' + o.classes.hide;\n      el = document.elementFromPoint(x, y);\n      p.className = state;\n      return el;\n    }\n  };\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove',\n        wheel: 'wheel'\n      },\n      $el = angular.element(el);\n\n    $el[op](touch[type], fn)\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = _cache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      _cache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function hasClass(el, className) {\n    return (' ' + el.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n    return host[coord];\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n}]);\n"],"sourceRoot":"/source/"}