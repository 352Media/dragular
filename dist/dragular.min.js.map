{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/dragularDirective.js","dragular.js","src/dragularModule.js","src/dragularService.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","undefined","dragular","./dragularModule",2,"angular","dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","$el","element","never","always","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","addClass","className","indexOf","rmClass","removeClass","hasClass","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","domIndexOf","child","parent","Array","prototype","children","_mirror","containersNameSpaced","containersNameSpacedModel","initialContainers","options","proceedNameSpaces","_containers","nameSpace","push","apply","makeArray","all","isArray","iAll","newArray","manipulateContainers","changes","forEach","container","containers","console","warn","splice","isContainer","api","containersModel","_lastTargetModel","_targetModel","_containersModel","_lastTargetScope","_targetScope","scope","isContainerNameSpaced","tryScope","isContainerModel","found","hasOwnProperty","target","isolateScope","events","rem","documentElement","release","grab","destroy","removeContainer","window","event","item","which","metaKey","ctrlKey","start","direction","parentElement","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","_item","_offsetX","_offsetY","_clientX","_clientY","boundingBox","_offsetXr","_offsetYb","delay","_renderTimer","setTimeout","renderMirrorAndDrag","preventDefault","renderMirrorImage","style","drag","handle","dragging","_isContainer","invalid","moves","_itemModel","_sourceModel","end","containerIndex","itemIndex","_initialIndex","_currentIndex","copy","_copyModel","_copy","cloneNode","classes","transit","$emit","_source","_initialSibling","_currentSibling","invalidTarget","tagName","drop","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","removeOnSpill","remove","cancel","_targetContainer","dragOverClasses","_lastOverElem","_lastOverClass","isInitialPlacement","cleanup","itemModel","removeChild","revert","reverts","arguments","revertOnSpill","initial","moveInContainersModel","insertBefore","removeMirrorImage","clearTimeout","clientX","clientY","accepted","accepts","immediate","getImmediateChild","reference","getReference","overActive","overAccepts","overDeclines","offsetBox","x","y","lockY","_mirrorWidth","lockX","_mirrorHeight","referenceIndex","$apply","scrollContainer","scrollTop","deltaY","getBoundingClientRect","mirror","body","appendChild","unselectable","outside","len","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","hide","document","elementFromPoint","defaultClasses","extend","addContainer"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global angular */\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.directive('dragular', ['dragularService', function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n      dragularService(iElm[0], $scope[iAttrs.dragular || 'undefined'] || tryJson(iAttrs.dragular));\n\n      function tryJson(json) {\n        try {\n          return JSON.parse(json);\n        } catch (e) {\n          console.log(e, 'Dragular: not valid JSON for options!', iElm);\n          return undefined;\n        }\n      }\n    }\n  };\n}])\n",null,"/* global angular */\n'use strict';\n\n\n\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n","/* global angular */\n'use strict';\n\n/**\n * dragular Module and Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.factory('dragularService', function dragula() {\n\n  var containersNameSpaced = {}, // name-spaced containers\n    containersNameSpacedModel = {}, // name-spaced containers models\n      _mirror; // mirror image\n\n  return function(initialContainers, options) {\n\n    if (arguments.length === 1 && !Array.isArray(initialContainers) && !angular.isElement(initialContainers) && !initialContainers[0]) {\n      // then containers are not provided, only options\n      options = initialContainers;\n      initialContainers = [];\n    }\n\n    var body = document.body,\n      documentElement = document.documentElement,\n      _source, // source container\n      _item, // item being dragged\n      _sourceModel, // source container model\n      _itemModel, // item-model being dragged\n      _targetModel, // target container model\n      _lastTargetModel, // last target container model\n      _targetScope, // target model scope (used for $apply-ing changes in model)\n      _lastTargetScope, // target model scope (used for $apply-ing changes in model)\n      _offsetX, // reference x\n      _offsetY, // reference y\n      _offsetXr, // reference x right for boundingBox feature\n      _offsetYb, // reference y bottom for boundingBox feature\n      _clientX, // cache client x, init at grab, update at drag\n      _clientY, // cache client y, init at grab, update at drag\n      _mirrorWidth, // mirror width for boundingBox feature\n      _mirrorHeight, // mirror height for boundingBox feature\n      _initialSibling, // reference sibling when grabbed\n      _currentSibling, // reference sibling now\n      _initialIndex, // reference model index when grabbed\n      _currentIndex, // reference model index now\n      _lastOverElem, // last element behind the cursor (dragOverClasses feature)\n      _lastOverClass, // last overClass used (dragOverClasses feature)\n      _copy, // item used for copying\n      _copyModel, // item-model used for copying\n      _containers = {}, // containers managed by the drake\n      _containersModel = {}, // containers model\n      _renderTimer, // timer for setTimeout renderMirrorImage\n      _isContainer, // internal isContainer\n      _targetContainer, // droppable container under drag item\n      defaultClasses = {\n        mirror: 'gu-mirror',\n        hide: 'gu-hide',\n        unselectable: 'gu-unselectable',\n        transit: 'gu-transit',\n        overActive: 'gu-over-active',\n        overAccepts: 'gu-over-accept',\n        overDeclines: 'gu-over-decline'\n      },\n      o = { // options\n        classes: defaultClasses,\n        containers: false,\n        moves: always,\n        accepts: always,\n        isContainer: never,\n        copy: false,\n        delay: false,\n        invalid: invalidTarget,\n        revertOnSpill: false,\n        removeOnSpill: false,\n        dragOverClasses: false,\n        lockX: false,\n        lockY: false,\n        boundingBox: false,\n        containersModel: false\n      };\n\n    if (!isElement(o.boundingBox)) {\n      o.boundingBox = null;\n    }\n\n    if (options && options.classes) {\n      angular.extend(defaultClasses, options.classes);\n      angular.extend(options.classes, defaultClasses);\n    }\n\n    angular.extend(o, options);\n\n    if (o.delay === true) {\n      o.delay = 300;\n    }\n\n    // get initial containers from options, argument or fall back to empty array (containers can be added later)\n    initialContainers = o.containers || (initialContainers ? makeArray(initialContainers) : []);\n    if(o.containers){\n      // make array from o.containers\n      initialContainers = makeArray(initialContainers);\n    }\n    if(o.containersModel){\n      o.containersModel = makeArray(o.containersModel);\n    }\n\n    // feed namespaced containers groups and optionaly shadow it by models\n    if (o.nameSpace) {\n       if (!Array.isArray(o.nameSpace)) {\n          o.nameSpace = [o.nameSpace];\n       }\n       function proceedNameSpaces(_containers, containersNameSpaced, nameSpace, initialContainers){\n        if (!containersNameSpaced[nameSpace]) {\n          containersNameSpaced[nameSpace] = [];\n        }\n        Array.prototype.push.apply(containersNameSpaced[nameSpace], initialContainers);\n        _containers[nameSpace] = containersNameSpaced[nameSpace];\n       }\n      o.nameSpace.forEach(function eachNameSpace (nameSpace) {\n        proceedNameSpaces(_containers, containersNameSpaced, nameSpace, initialContainers);\n        if(o.containersModel){\n          proceedNameSpaces(_containersModel, containersNameSpacedModel, nameSpace, o.containersModel)\n        }\n      });\n      _isContainer = isContainerNameSpaced;\n    }else{\n      // default (not using nameSpaces)\n      _containers = initialContainers;\n      _isContainer = isContainer;\n      if(o.containersModel){\n          _containersModel = o.containersModel;\n        }\n    }\n\n    //register events\n    events();\n\n    var api = {\n      addContainer: manipulateContainers('add'),\n      removeContainer: manipulateContainers('remove'),\n      containers: _containers,\n      start: start,\n      end: end,\n      cancel: cancel,\n      remove: remove,\n      destroy: destroy,\n      dragging: false\n    };\n\n    return api;\n\n    // make array from array-like objects or from single element\n    function makeArray(all) {\n      if (Array.isArray(all)) {\n        return all;\n      }\n      if (all.length) { // is array-like\n        var iAll = all.length,\n          newArray = [];\n        while (iAll) {\n          iAll--;\n          newArray.push(all[iAll]);\n        }\n        return newArray;\n      } else { // is one element\n        return [all];\n      }\n    }\n\n    // add or remove containers - deprecated\n    function manipulateContainers(op) {\n      return function addOrRemove(all) {\n        var changes = Array.isArray(all) ? all : makeArray(all);\n        changes.forEach(function forEachContainer(container) {\n          if(o.nameSpace){\n            angular.forEach(o.nameSpace, function addRemoveNamespaced (containers, nameSpace) {\n              if (op === 'add') {\n                _containers[nameSpace].push(container);\n                console.warn && console.warn('drake.addContainer is deprecated. please access drake.containers directly, instead');\n              } else {\n                _containers[nameSpace].splice(_containers.indexOf(container), 1);\n                console.warn && console.warn('drake.removeContainer is deprecated. please access drake.containers directly, instead');\n              }\n            });\n          }else{\n            if (op === 'add') {\n              _containers.push(container);\n              console.warn && console.warn('drake.addContainer is deprecated. please access drake.containers directly, instead');\n            } else {\n              _containers.splice(_containers.indexOf(container), 1);\n              console.warn && console.warn('drake.removeContainer is deprecated. please access drake.containers directly, instead');\n            }\n          }\n        });\n      };\n    }\n\n    function isContainer(el) {\n      if(api.containers.indexOf(el) !== -1 || o.isContainer(el)){\n        if(o.containersModel){\n          _lastTargetModel = _targetModel;\n          _targetModel = _containersModel[api.containers.indexOf(el)];\n          // track scopes too\n          _lastTargetScope = _targetScope;\n          _targetScope = angular.element(el).scope();\n        }\n        return true;\n      }\n      return false;\n    }\n\n    function isContainerNameSpaced(el) {\n      var nameSpace;\n      for (nameSpace in api.containers) {\n          if (api.containers.hasOwnProperty(nameSpace) && api.containers[nameSpace].indexOf(el) !== -1) {\n              if(o.containersModel){\n                _lastTargetModel = _targetModel;\n                _targetModel = _containersModel[nameSpace][api.containers[nameSpace].indexOf(el)];\n                // track scopes too\n                _lastTargetScope = _targetScope;\n                _targetScope = angular.element(el).scope();\n              }\n              return true;\n          }\n      }\n      if(o.isContainer(el)){\n        if(o.containersModel && o.isContainerModel){\n          var found = false;\n          function tryScope (scope) {\n            if(scope && scope[o.isContainerModel]){\n              found = true;\n              _lastTargetModel = _targetModel;\n              _targetModel = scope[o.isContainerModel];\n              _lastTargetScope = _targetScope;\n              _targetScope = angular.element(el).scope();\n            }\n          }\n          tryScope(angular.element(target).isolateScope());\n          if(!found){ // dont search in scope if already found in isolateScope\n            tryScope(angular.element(target).scope());\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n\n    function events(rem) {\n      var op = rem ? 'off' : 'on';\n      regEvent(documentElement, op, 'mouseup', release);\n\n      initialContainers.forEach(function addMouseDown (container) {\n        regEvent(container, 'on', 'mousedown', grab);\n      });\n    }\n\n    function destroy() {\n      events(true);\n      api.removeContainer(_containers);\n      release({});\n    }\n\n    function grab(e) {\n      e = e || window.event;\n      var item = e.target;\n\n      // filter some odd situations\n      if ((e.which !== 0 && e.which !== 1) || e.metaKey || e.ctrlKey) {\n        return; // we only care about honest-to-god left clicks and touch events\n      }\n\n      // check if drag can start\n      if (start(item) !== true) {\n        return;\n      }\n\n      // automaticly detect direction of elements if not set in options\n      if (!o.direction) {\n        var parent = item.parentElement,\n          parentHeight = parent.offsetHeight,\n          parentWidth = parent.offsetWidth,\n          childHeight = item.clientHeight,\n          childWidth = item.clientWidth;\n        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n      }\n\n      // get initial coordinates, used to render _mirror for first time\n      var offset = getOffset(_item);\n      _offsetX = getCoord('pageX', e) - offset.left;\n      _offsetY = getCoord('pageY', e) - offset.top;\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // limiting area of _mirror movement, get initial coordinates\n      if (o.boundingBox) {\n        _offsetXr = getCoord('pageX', e) - offset.right;\n        _offsetYb = getCoord('pageY', e) - offset.bottom;\n      }\n\n      // delayed rendering\n      if (typeof o.delay === 'number') {\n        _renderTimer = setTimeout(function() {\n          renderMirrorAndDrag(e);\n        }, o.delay);\n      } else {\n        renderMirrorAndDrag(e);\n      }\n\n      e.preventDefault();\n    }\n\n    function renderMirrorAndDrag(e) {\n      renderMirrorImage();\n      // initial position\n      _mirror.style.left = _clientX - _offsetX + 'px';\n      _mirror.style.top = _clientY - _offsetY + 'px';\n\n      drag(e);\n    }\n\n\n    function start(item) {\n      var handle = item;\n\n      if (api.dragging && _mirror) {\n        return false; // already dragging\n      }\n\n      if (_isContainer(item)) {\n        return false; // don't drag container itself\n      }\n\n      while (!_isContainer(item.parentElement)) {\n        // break loop if user tries to drag item which is considered invalid handle\n        if (o.invalid(item, handle)) {\n          return false;\n        }\n        item = item.parentElement; // drag target should be immediate child of container\n        if (!item) {\n          return;\n        }\n      }\n\n      // last item chceck\n      if (o.invalid(item, handle)) {\n        return false;\n      }\n\n      var container = item.parentElement;\n      if (!o.moves(item, container, handle, _itemModel, _sourceModel)) { // is movable\n        return false;\n      }\n\n      end();\n\n      // prepare models operations\n      if (o.containersModel){\n        var containerIndex = initialContainers.indexOf(container),\n          itemIndex = domIndexOf(item, container);\n\n        _initialIndex = _currentIndex = itemIndex;\n        _sourceModel = o.containersModel[containerIndex];\n        _itemModel = _sourceModel[itemIndex];\n        if(o.copy){\n          _copyModel = angular.copy(_itemModel);\n        }\n        console.log('starting drag',_itemModel);\n      }\n\n      if (o.copy) {\n        _copy = item.cloneNode(true);\n        addClass(_copy, o.classes.transit);\n        if (o.scope) {\n          o.scope.$emit('cloned', _copy, item, _copyModel, _itemModel);\n        }\n      } else {\n        addClass(item, o.classes.transit);\n      }\n\n      _source = container;\n      _item = item;\n      _initialSibling = _currentSibling = nextEl(item);\n\n      api.dragging = true;\n      if (o.scope) {\n        o.scope.$emit('drag', _item, _source);\n      }\n\n      return true;\n    }\n\n    function invalidTarget(el) {\n      return el.tagName === 'A' || el.tagName === 'BUTTON';\n    }\n\n    function end() {\n      console.log('end');\n      if (!api.dragging) {\n        return;\n      }\n      console.log('end-drop');\n      var item = _copy || _item;\n      drop(item, item.parentElement);\n    }\n\n    function release(e) {\n      if (!api.dragging) {\n        return;\n      }\n      e = e || window.event;\n\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      var item = _copy || _item,\n        elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY);\n\n      if (dropTarget && (o.copy === false || dropTarget !== _source)) {\n        // found valid target and (is not copy case or target is not initial container)\n        drop(item, dropTarget);\n      } else if (o.removeOnSpill) {\n        remove();\n      } else {\n        cancel();\n      }\n\n      // after release there is no container hovered\n      _targetContainer = null;\n\n      // remove classes if used\n      if (o.dragOverClasses && _lastOverElem) {\n        rmClass(_lastOverElem, _lastOverClass);\n        _lastOverElem = null;\n      }\n    }\n\n    function drop(item, target) {\n      if (o.scope && isInitialPlacement(target)) {\n        o.scope.$emit('cancel', item, _source, _copyModel || _itemModel, _sourceModel, _targetModel);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, target, _source, _copyModel || _itemModel, _sourceModel, _targetModel);\n      }\n      cleanup();\n    }\n\n    function remove() {\n      if (!api.dragging) {\n        return;\n      }\n      var item = _copy || _item,\n        parent = item.parentElement;\n\n      if(!o.containersModel){\n        if(parent){\n          parent.removeChild(item);\n        }\n      }else{\n        var itemModel = _copyModel || _itemModel;\n        console.log('removing item/copy from curent target');\n        _targetModel.splice(_targetModel.indexOf(itemModel),1);\n      }\n\n      if (o.scope) {\n        o.scope.$emit(o.copy ? 'cancel' : 'remove', item, parent, itemModel, _sourceModel, _targetModel);\n      }\n      cleanup();\n    }\n\n    function cancel(revert) {\n      if (!api.dragging) {\n        return;\n      }\n      var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n        item = _copy || _item,\n        parent = item.parentElement;\n\n      if (parent === _source && o.copy) {\n        if(!o.containersModel){\n          parent.removeChild(_copy);\n        }else{\n          console.log('_copyModel');\n          _targetModel.splice(_targetModel.indexOf(_copyModel), 1, _copyModel);\n        }\n      }\n\n      var initial = isInitialPlacement(parent);\n      if (initial === false && o.copy === false && reverts) {\n        console.log('reverting item/copy back to source');\n        if(!o.containersModel){\n          _source.insertBefore(item, _initialSibling);\n        }else{\n          _lastTargetModel = _targetModel;\n          _targetModel = _sourceModel;\n          // track scopes too\n          _lastTargetScope = _targetScope;\n          _targetScope = angular.element(el).scope();\n          // move back to initial placement\n          moveInContainersModel(_initialIndex);\n        }\n      }\n\n      if (o.scope && (initial || reverts)) {\n        o.scope.$emit('cancel', item, _source);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, parent, _source);\n      }\n\n      cleanup();\n    }\n\n    function cleanup() {\n      var item = _copy || _item;\n      removeMirrorImage();\n\n      if (item) {\n        rmClass(item, o.classes.transit);\n      }\n\n      // cancel timer\n      if (_renderTimer) {\n        clearTimeout(_renderTimer);\n      }\n\n      _source = _item = _copy = _initialSibling = _currentSibling = _sourceModel = null;\n      _itemModel = _copyModel = _initialIndex = _currentIndex = _renderTimer = null;\n\n      api.dragging = false;\n      if (o.scope) {\n        o.scope.$emit('dragend', item);\n      }\n    }\n\n    // is item currently placed in original container and original position?\n    function isInitialPlacement(target, s) {\n      var sibling = s || (_mirror ? _currentSibling : nextEl(_item || _copy));\n      return target === _source && sibling === _initialSibling;\n    }\n\n    // find valid drop container\n    function findDropTarget(elementBehindCursor, clientX, clientY) {\n      var target = elementBehindCursor;\n      while (target && !accepted()) {\n        target = target.parentElement;\n      }\n      return target;\n\n      function accepted() {\n        var accepts = false;\n\n        if (_isContainer(target)) { // is droppable?\n           _targetContainer = target;\n\n          var immediate = getImmediateChild(target, elementBehindCursor),\n            reference = getReference(target, immediate, clientX, clientY),\n            initial = isInitialPlacement(target, reference);\n          accepts = initial ? true : o.accepts(_item, target, _source, reference, _itemModel, _sourceModel);\n        }\n\n        // add class if element is enabled for it and it has not already the class\n        if (o.dragOverClasses &&\n          hasClass(target, o.classes.overActive) &&\n          target !== _lastOverElem) {\n\n          if (_lastOverElem) { // clear from previous\n            rmClass(_lastOverElem, _lastOverClass);\n          }\n\n          _lastOverClass = accepts ? o.classes.overAccepts : o.classes.overDeclines;\n          addClass(target, _lastOverClass);\n          _lastOverElem = target;\n        }\n\n        return accepts;\n      }\n    }\n\n    function drag(e) {\n      if (!_mirror) {\n        return;\n      }\n      e = e || window.event;\n\n      // update coordinates\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // count mirror coordiates\n      var x = _clientX - _offsetX,\n        y = _clientY - _offsetY,\n        pageX,\n        pageY,\n        offsetBox;\n\n      // fill extra properties if boundingBox is used\n      if (o.boundingBox) {\n        pageX = getCoord('pageX', e);\n        pageY = getCoord('pageY', e);\n        offsetBox = getOffset(o.boundingBox);\n      }\n\n      if (!o.lockY) {\n        if (!o.boundingBox || (pageX > offsetBox.left + _offsetX && pageX < offsetBox.right + _offsetXr)) {\n          _mirror.style.left = x + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageX < offsetBox.left + _offsetX) {\n            _mirror.style.left = _clientX - (pageX - offsetBox.left) + 'px';\n          } else {\n            _mirror.style.left = _clientX - _mirrorWidth - (pageX - offsetBox.right) + 'px';\n          }\n        }\n      }\n      if (!o.lockX) {\n        if (!o.boundingBox || (pageY > offsetBox.top + _offsetY && pageY < offsetBox.bottom + _offsetYb)) {\n          _mirror.style.top = y + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageY < offsetBox.top + _offsetY) {\n            _mirror.style.top = _clientY - (pageY - offsetBox.top) + 'px';\n          } else {\n            _mirror.style.top = _clientY - _mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n          }\n        }\n      }\n\n      var item = _copy || _item,\n        elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY);\n\n      // do not copy in same container\n      if (dropTarget === _source && o.copy) {\n        return;\n      }\n\n      var reference,\n        immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n      // prepare models operations\n      if(o.containersModel){\n        var referenceIndex;\n\n        _lastTargetScope = _targetScope || angular.element(_source).scope();\n        _targetScope = angular.element(dropTarget).scope();\n      }\n\n      if (immediate !== null) {\n        reference = getReference(dropTarget, immediate, _clientX, _clientY);\n        if(o.containersModel){\n          referenceIndex = domIndexOf(reference, dropTarget);\n        }\n      } else if (o.revertOnSpill === true && !o.copy) {\n        // the case that mirror is not over valid target and reverting is on and copy is off\n        reference = _initialSibling;\n        dropTarget = _source;\n\n        // getting model intitial properties into current\n        if(o.containersModel){\n          referenceIndex = _initialIndex;\n          _lastTargetModel = _targetModel;\n          _targetModel = _sourceModel;\n          _lastTargetScope = _targetScope;\n          _targetScope = angular.element(dropTarget).scope();\n        }\n      } else {\n        // the case that mirror is not over valid target and removing is on or copy is on\n        if ((o.copy || o.removeOnSpill === true) && item.parentElement !== null) {\n          console.log(o.copy ? 'remove item copy from last position' : 'remove item from last position')\n          // remove item or copy of item\n          if(!o.containersModel){\n            item.parentElement.removeChild(item);\n          }else{\n            _targetModel.splice(referenceIndex, 1);\n            _targetScope.$apply();\n          }\n        }\n        return;\n      }\n      if (reference === null || reference !== item && reference !== nextEl(item)) {\n        // moving item/copy to new container from previous one\n        console.log('moving item/copy to new placement');\n        _currentSibling = reference;\n\n        if(!o.containersModel){\n          dropTarget.insertBefore(item, reference);\n        }else{\n          moveInContainersModel(referenceIndex);\n          _currentIndex = referenceIndex;\n        }\n\n        if (o.scope) {\n          o.scope.$emit('shadow', item, dropTarget);\n        }\n      }\n    }\n\n    function moveInContainersModel (referenceIndex) {\n      console.log(_lastTargetModel[_currentIndex]);\n      if(_lastTargetModel === _targetModel){\n        _targetModel.splice(referenceIndex, 0, _lastTargetModel.splice(_currentIndex, 1)[0]);\n      }else{\n        _lastTargetModel.splice(_currentIndex, 1);\n        _targetModel.splice(referenceIndex, 0, _copyModel || _itemModel);\n        _lastTargetScope.$apply();\n      }\n      _targetScope.$apply();\n    }\n\n    function scrollContainer(e){\n      if(_targetContainer){_targetContainer.scrollTop += e.deltaY};\n    }\n\n    function renderMirrorImage() {\n      if (_mirror) {\n        return;\n      }\n      var rect = _item.getBoundingClientRect();\n      _mirror = _item.cloneNode(true);\n      _mirrorWidth = rect.width;\n      _mirrorHeight = rect.height;\n      _mirror.style.width = getRectWidth(rect) + 'px';\n      _mirror.style.height = getRectHeight(rect) + 'px';\n      rmClass(_mirror, o.classes.transit);\n      addClass(_mirror, o.classes.mirror);\n      body.appendChild(_mirror);\n      regEvent(documentElement, 'on', 'mousemove', drag);\n      addClass(body, o.classes.unselectable);\n      regEvent(_mirror, 'on', 'wheel', scrollContainer);\n      if (o.scope) {\n        o.scope.$emit('cloned', _mirror, _item);\n      }\n    }\n\n    function removeMirrorImage() {\n      if (_mirror) {\n        rmClass(body, o.classes.unselectable);\n        regEvent(documentElement, 'off', 'mousemove', drag);\n        regEvent(_mirror, 'off', 'wheel', scrollContainer);\n        _mirror.parentElement.removeChild(_mirror);\n        _mirror = null;\n      }\n    }\n\n    function getImmediateChild(dropTarget, target) {\n      var immediate = target;\n      while (immediate !== dropTarget && immediate.parentElement !== dropTarget) {\n        immediate = immediate.parentElement;\n      }\n      if (immediate === documentElement) {\n        return null;\n      }\n      return immediate;\n    }\n\n    function getReference(dropTarget, target, x, y) {\n      var horizontal = o.direction === 'horizontal';\n      var reference = target !== dropTarget ? inside() : outside();\n      return reference;\n\n      function outside() { // slower, but able to figure out any position\n        var len = dropTarget.children.length;\n        var i;\n        var el;\n        var rect;\n        for (i = 0; i < len; i++) {\n          el = dropTarget.children[i];\n          rect = el.getBoundingClientRect();\n          if (horizontal && rect.left > x) {\n            return el;\n          }\n          if (!horizontal && rect.top > y) {\n            return el;\n          }\n        }\n        return null;\n      }\n\n      function inside() { // faster, but only available if dropped inside a child element\n        var rect = target.getBoundingClientRect();\n        if (horizontal) {\n          return resolve(x > rect.left + getRectWidth(rect) / 2);\n        }\n        return resolve(y > rect.top + getRectHeight(rect) / 2);\n      }\n\n      function resolve(after) {\n        return after ? nextEl(target) : target;\n      }\n    }\n\n    function getScroll(scrollProp, offsetProp) {\n      if (typeof window[offsetProp] !== 'undefined') {\n        return window[offsetProp];\n      }\n      if (documentElement.clientHeight) {\n        return documentElement[scrollProp];\n      }\n      return body[scrollProp];\n    }\n\n    function getOffset(el) {\n      var rect = el.getBoundingClientRect(),\n        scrollTop = getScroll('scrollTop', 'pageYOffset'),\n        scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n      return {\n        left: rect.left + scrollLeft,\n        right: rect.right + scrollLeft,\n        top: rect.top + scrollTop,\n        bottom: rect.bottom + scrollTop\n      };\n    }\n\n    function getElementBehindPoint(point, x, y) {\n      if (!x && !y) {\n        return null;\n      }\n      var p = point || {},\n        state = p.className,\n        el;\n      p.className += ' ' + o.classes.hide;\n      el = document.elementFromPoint(x, y);\n      p.className = state;\n      return el;\n    }\n  };\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if(type !== 'wheel'){$el[op](touch[type], fn)};\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function addClass(el, className) {\n    if (el.className.indexOf(' ' + className) === -1) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    angular.element(el).removeClass(className);\n  }\n\n  function hasClass(el, className) {\n    return (' ' + el.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n    return host[coord];\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function domIndexOf(child, parent){\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n});\n"],"sourceRoot":"/source/"}