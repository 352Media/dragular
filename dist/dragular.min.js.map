{"version":3,"sources":["dragular.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","undefined","options","dragular","containersModel","$eval","./dragularModule",2,"angular","dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","$rootScope","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","$el","element","never","always","emptyObj","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","lookupClass","className","cached","shared","classesCache","lastIndex","RegExp","addClass","current","test","rmClass","replace","trim","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","domIndexOf","child","parent","Array","prototype","indexOf","children","fireEvent","target","extra","dispatchEvent","eventType","containers","mirror","source","item","sourceItem","sourceModel","lastDropTarget","offsetX","offsetY","offsetXr","offsetYb","clientX","clientY","mirrorWidth","mirrorHeight","initialSibling","currentSibling","initialIndex","currentIndex","isContainerModel","targetContainer","dragOverEvents","lastElementBehindCursor","grabbed","serviceFn","initialContainers","proceedContainers","nameSpace","initial","push","apply","makeArray","all","startIndex","isArray","slice","removeContainers","applyAsync","changes","forEach","container","index","splice","events","remove","documentElement","release","grab","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","destroy","preventDefault","window","event","which","metaKey","ctrlKey","context","canStart","end","start","direction","parentElement","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","boundingBox","classes","transit","renderMirrorImage","style","drag","drake","dragging","handle","isContainer","invalid","moves","manualStart","copy","cloneNode","scope","$emit","containerIndex","invalidTarget","drop","ungrab","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","removeOnSpill","cancel","isInitialPlacement","dropElm","dropIndex","$applyAsync","targetModel","dropElmModel","removeChild","cleanup","revert","reverts","arguments","revertOnSpill","insertBefore","removeMirrorImage","spillOut","accepted","accepts","immediate","getImmediateChild","reference","getReference","moved","spillOver","over","changed","out","offsetBox","x","y","lockY","lockX","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","getBoundingClientRect","mirrorContainer","appendChild","body","unselectable","outside","len","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","document","elementFromPoint","defaultClasses","dragOverEventNames","extend","dragOverEvent","createEvent","initEvent","createEventObject","cleanEnviroment"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.directive('dragular', ['dragularService', function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope[iAttrs.dragular] || tryJson(iAttrs.dragular);\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}]);\n\n},{\"./dragularModule\":2}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n\n\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n\n},{\"./dragularDirective.js\":1,\"./dragularService.js\":3}],3:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Module and Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\n/**\n * @ngInject\n */\n\ndragularModule.factory('dragularService', ['$rootScope', function dragula($rootScope) {\n\n  var shared = { // function returned as service\n      classesCache: {}, // classes lookup cache\n      containersModel: {}, // containers model\n      containers: {}, // containers managed by the drake\n      mirror: null, // mirror image\n      source: null, // source container\n      item: null, // item being dragged\n      sourceItem: null, // item originaly dragged if copy is enabled\n      sourceModel: null, // source container model\n      lastDropTarget: null, // last container item was over\n      offsetX: null, // reference x\n      offsetY: null, // reference y\n      offsetXr: null, // reference x right for boundingBox feature\n      offsetYb: null, // reference y bottom for boundingBox feature\n      clientX: null, // cache client x, init at grab, update at drag\n      clientY: null, // cache client y, init at grab, update at drag\n      mirrorWidth: null, // mirror width for boundingBox feature\n      mirrorHeight: null, // mirror height for boundingBox feature\n      initialSibling: null, // reference sibling when grabbed\n      currentSibling: null, // reference sibling now\n      initialIndex: null, // reference model index when grabbed\n      currentIndex: null, // reference model index now\n      isContainerModel: null, // if o.isContainer is used, model can be provided as well, here it is kept\n      targetContainer: null, // droppable container under drag item\n      dragOverEvents: {}, // drag over events fired on element behind cursor\n      lastElementBehindCursor: null, // last element behind cursor\n      grabbed: null // holds mousedown context until first mousemove\n    },\n    serviceFn = function(initialContainers, options) {\n\n      if (arguments.length === 1 && !Array.isArray(initialContainers) && !angular.isElement(initialContainers) && !initialContainers[0]) {\n        // then containers are not provided, only options\n        options = initialContainers;\n        initialContainers = [];\n      }\n\n      var body = document.body,\n        documentElement = document.documentElement,\n        defaultClasses = {\n          mirror: 'gu-mirror',\n          hide: 'gu-hide',\n          unselectable: 'gu-unselectable',\n          transit: 'gu-transit'\n        },\n        isContainer, // internal isContainer\n        o = { // options\n          dragOverEventNames: ['dragularenter', 'dragularleave', 'dragularrelease'],\n          classes: defaultClasses,\n          containers: false,\n          moves: always,\n          accepts: always,\n          isContainer: never,\n          copy: false,\n          invalid: invalidTarget,\n          revertOnSpill: false,\n          removeOnSpill: false,\n          lockX: false,\n          lockY: false,\n          boundingBox: false,\n          containersModel: false,\n          isContainerModel: emptyObj\n        };\n\n      if (!isElement(o.boundingBox)) {\n        o.boundingBox = null;\n      }\n\n      if (options && options.classes) {\n        angular.extend(defaultClasses, options.classes);\n        angular.extend(options.classes, defaultClasses);\n      }\n\n      angular.extend(o, options);\n\n      if (!o.mirrorContainer) {\n        o.mirrorContainer = document.body;\n      }\n\n      // get initial containers from options, argument or fall back to empty array (containers can be also added later)\n      initialContainers = o.containers || initialContainers || [];\n      initialContainers = makeArray(initialContainers);\n\n      if (o.containersModel) {\n        //                            is 2D array?\n        o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n      }\n\n      function proceedContainers(containers, nameSpace, initial) {\n        if (!containers[nameSpace]) {\n          containers[nameSpace] = [];\n        }\n        Array.prototype.push.apply(containers[nameSpace], initial);\n      }\n\n      // feed containers groups and optionaly shadow it by models\n      if (!o.nameSpace) {\n        o.nameSpace = ['dragularCommon'];\n      }\n      if (!Array.isArray(o.nameSpace)) {\n        o.nameSpace = [o.nameSpace];\n      }\n      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n        proceedContainers(shared.containers, nameSpace, initialContainers);\n        if (o.containersModel) {\n          proceedContainers(shared.containersModel, nameSpace, o.containersModel);\n        }\n      });\n\n      //register events\n      events();\n\n      angular.forEach(o.dragOverEventNames, function prepareDragOverEvents(dragOverEvent) {\n        if (document.createEvent) {\n          shared.dragOverEvents[dragOverEvent] = document.createEvent('HTMLEvents');\n          shared.dragOverEvents[dragOverEvent].initEvent(dragOverEvent, true, true);\n        } else {\n          shared.dragOverEvents[dragOverEvent] = document.createEventObject();\n          shared.dragOverEvents[dragOverEvent].eventType = dragOverEvent;\n        }\n      });\n\n      isContainer = function isContainer(el) {\n        var i = o.nameSpace.length;\n        while (i--) {\n          if (shared.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n            return true;\n          }\n        }\n        if (o.isContainer(el)) {\n          shared.isContainerModel = o.isContainerModel(el);\n          return true;\n        } else {\n          shared.isContainerModel = null;\n        }\n        return false;\n      };\n\n      var drake = {\n        containers: shared.containers,\n        containersModel: shared.containersModel,\n        isContainer: isContainer,\n        start: manualStart,\n        end: end,\n        cancel: cancel,\n        remove: remove,\n        destroy: destroy,\n        dragging: false\n      };\n\n      return drake;\n\n      // make array from array-like objects or from single element (based on bevacqua/atoa)\n      function makeArray(all, startIndex) {\n        if (Array.isArray(all)) {\n          return all;\n        }\n        if (all.length) { // is array-like\n          return Array.prototype.slice.call(all, startIndex);\n        } else { // is one element\n          return [all];\n        }\n      }\n\n      // add or remove containers - deprecated\n      function removeContainers(all) {\n        $rootScope.applyAsync(function applyDestroyed() {\n          var changes = Array.isArray(all) ? all : makeArray(all);\n          changes.forEach(function forEachContainer(container) {\n            angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n              var index;\n              index = shared.containers[nameSpace].indexOf(container);\n              shared.containers[nameSpace].splice(index, 1);\n              if (o.containersModel) {\n                shared.containersModel[nameSpace].splice(index, 1);\n              }\n            });\n          });\n        });\n      }\n\n      function events(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(documentElement, op, 'mouseup', release);\n\n        initialContainers.forEach(function addMouseDown(container) {\n          regEvent(container, 'on', 'mousedown', grab);\n        });\n      }\n\n      function eventualMovements(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(documentElement, op, 'mousemove', startBecauseMouseMoved);\n      }\n\n      function movements(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(documentElement, op, 'selectstart', preventGrabbed); // IE8\n        regEvent(documentElement, op, 'click', preventGrabbed);\n        regEvent(documentElement, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n      }\n\n      function destroy() {\n        events(true);\n        removeContainers(initialContainers);\n        release({});\n      }\n\n      function preventGrabbed(e) {\n        if (shared.grabbed) {\n          e.preventDefault();\n        }\n      }\n\n      function grab(e) {\n        e = e || window.event;\n\n        // filter some odd situations\n        if ((e.which !== 0 && e.which !== 1) || e.metaKey || e.ctrlKey) {\n          return; // we only care about honest-to-god left clicks and touch events\n        }\n\n        var context = canStart(e.target);\n        if (!context) {\n          return;\n        }\n\n        shared.grabbed = context;\n        eventualMovements();\n        if (e.type === 'mousedown') {\n          e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n        }\n      }\n\n      function startBecauseMouseMoved(e) {\n        eventualMovements(true); // remove mousemove listener\n        movements();\n        end();\n        start(shared.grabbed);\n\n        // automaticly detect direction of elements if not set in options\n        if (!o.direction) {\n          var parent = shared.sourceItem.parentElement,\n            parentHeight = parent.offsetHeight,\n            parentWidth = parent.offsetWidth,\n            childHeight = shared.sourceItem.clientHeight,\n            childWidth = shared.sourceItem.clientWidth;\n          o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n        }\n\n        // get initial coordinates, used to render shared.mirror for first time\n        var offset = getOffset(shared.sourceItem);\n        shared.offsetX = getCoord('pageX', e) - offset.left;\n        shared.offsetY = getCoord('pageY', e) - offset.top;\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        // limiting area of shared.mirror movement, get initial coordinates\n        if (o.boundingBox) {\n          shared.offsetXr = getCoord('pageX', e) - offset.right;\n          shared.offsetYb = getCoord('pageY', e) - offset.bottom;\n        }\n\n        e.preventDefault();\n\n        addClass(shared.item, o.classes.transit);\n        renderMirrorImage();\n        // initial position\n        shared.mirror.style.left = shared.clientX - shared.offsetX + 'px';\n        shared.mirror.style.top = shared.clientY - shared.offsetY + 'px';\n\n        drag(e);\n      }\n\n\n      function canStart(item) {\n        if (drake.dragging && shared.mirror) {\n          return; // already dragging\n        }\n\n        var handle = item;\n\n        while (item.parentElement &&\n          !isContainer(item.parentElement)) {\n          // break loop if user tries to drag item which is considered invalid handle\n          if (o.invalid(item, handle)) {\n            return;\n          }\n          item = item.parentElement; // drag target should be immediate child of container\n          if (!item) {\n            return;\n          }\n        }\n\n        var source = item.parentElement;\n        if (!source ||\n          o.invalid(item, handle) ||\n          !o.moves(item, source, handle)) {\n          return;\n        }\n\n        return {\n          item: item,\n          source: source\n        };\n      }\n\n      function manualStart(item) {\n        var context = canStart(item);\n        if (context) {\n          start(context);\n        }\n      }\n\n      function start(context) {\n        shared.sourceItem = shared.item = context.item;\n        shared.source = context.source;\n        shared.initialSibling = shared.currentSibling = nextEl(context.item);\n\n        if (o.copy) {\n          shared.item = context.item.cloneNode(true);\n          if (o.scope) {\n            o.scope.$emit('cloned', shared.item, context.item);\n          }\n        }\n\n        // prepare models operations\n        if (o.containersModel) {\n          var containerIndex = initialContainers.indexOf(context.source);\n          shared.sourceModel = o.containersModel[containerIndex];\n          shared.initialIndex = domIndexOf(context.item, context.source);\n        }\n\n        drake.dragging = true;\n        if (o.scope) {\n          o.scope.$emit('drag', shared.sourceItem, shared.source);\n        }\n\n        return true;\n      }\n\n      function invalidTarget() {\n        return false;\n      }\n\n      function end() {\n        if (!drake.dragging) {\n          return;\n        }\n        drop(shared.item, shared.item.parentElement);\n      }\n\n      function ungrab() {\n        shared.grabbed = false;\n        eventualMovements(true);\n        movements(true);\n      }\n\n      function release(e) {\n        ungrab();\n        if (!drake.dragging) {\n          return;\n        }\n        e = e || window.event;\n\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n          dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY);\n\n        if (dropTarget && (o.copy === false || dropTarget !== shared.source)) {\n          // found valid target and (is not copy case or target is not initial container)\n          drop(shared.item, dropTarget);\n        } else if (o.removeOnSpill) {\n          remove();\n        } else {\n          cancel();\n        }\n\n        // after release there is no container hovered\n        shared.targetContainer = null;\n\n        if (shared.lastElementBehindCursor) {\n          fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents['dragularrelease'], elementBehindCursor);\n        }\n\n        if (o.scope) {\n          o.scope.$emit('release', shared.item, shared.source);\n        }\n      }\n\n      function drop(item, target) {\n        if (o.scope && isInitialPlacement(target)) {\n          o.scope.$emit('cancel', item, shared.source, shared.sourceModel, shared.initialIndex);\n        } else if (o.scope) {\n          o.scope.$emit('drop', item, target, shared.source, shared.sourceModel, shared.initialIndex);\n        }\n        if (o.containersModel && !isInitialPlacement(target)) {\n          var dropElm = item,\n            dropIndex = domIndexOf(dropElm, target);\n          $rootScope.$applyAsync(function applyDrop() {\n            if (target === shared.source) {\n              shared.sourceModel.splice(dropIndex, 0, shared.sourceModel.splice(shared.initialIndex, 1)[0]);\n            } else {\n              var targetModel,\n                dropElmModel = o.copy ? angular.copy(shared.sourceModel[shared.initialIndex]) : shared.sourceModel[shared.initialIndex];\n\n              if (!shared.isContainerModel) {\n                var i = o.nameSpace.length;\n                while (i--) {\n                  if (drake.containers[o.nameSpace[i]].indexOf(target) !== -1) {\n                    targetModel = shared.containersModel[o.nameSpace[i]][drake.containers[o.nameSpace[i]].indexOf(target)];\n                    break;\n                  }\n                }\n              } else {\n                targetModel = shared.isContainerModel;\n              }\n\n              target.removeChild(dropElm); // element must be removed for ngRepeat to apply correctly\n\n              if (!o.copy) {\n                shared.sourceModel.splice(shared.initialIndex, 1);\n              }\n              targetModel.splice(dropIndex, 0, dropElmModel);\n            }\n\n            if (item.parentElement) {\n              item.parentElement.removeChild(item);\n            }\n            cleanup();\n          });\n        } else {\n          cleanup();\n        }\n      }\n\n      function remove() {\n        if (!drake.dragging) {\n          return;\n        }\n        var parent = shared.item.parentElement;\n\n        if (parent) {\n          parent.removeChild(shared.item);\n        }\n\n        if (o.containersModel) {\n          $rootScope.$applyAsync(function removeModel() {\n            shared.sourceModel.splice(shared.initialIndex, 1);\n            cleanup();\n          });\n        }\n\n        if (o.scope) {\n          o.scope.$emit(o.copy ? 'cancel' : 'remove', shared.item, parent, shared.sourceModel, shared.initialIndex);\n        }\n        if (!o.containersModel) {\n          cleanup();\n        }\n      }\n\n      function cancel(revert) {\n        if (!drake.dragging) {\n          return;\n        }\n        var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n          parent = shared.item.parentElement;\n\n        var initial = isInitialPlacement(parent);\n        if (initial === false && o.copy === false && reverts) {\n          shared.source.insertBefore(shared.item, shared.initialSibling);\n        }\n        if (o.containersModel && !o.copy && !reverts) {\n          drop(shared.item, parent);\n        } else if (o.scope) {\n          if (initial || reverts) {\n            o.scope.$emit('cancel', shared.item, shared.source);\n          } else {\n            o.scope.$emit('drop', shared.item, parent, shared.source);\n          }\n        }\n\n        if (!o.containersModel || o.copy || reverts || initial) {\n          cleanup();\n        }\n      }\n\n      function cleanup() {\n        ungrab();\n        removeMirrorImage();\n\n        if (shared.item) {\n          rmClass(shared.item, o.classes.transit);\n        }\n\n        drake.dragging = false;\n\n        if (o.removeOnSpill === true) {\n          spillOut();\n        }\n\n        if (o.scope) {\n          o.scope.$emit('out', shared.item, shared.lastDropTarget, shared.source);\n          o.scope.$emit('dragend', shared.item);\n        }\n\n        shared.source = shared.item = shared.sourceItem = shared.initialSibling = shared.currentSibling = shared.sourceModel = null;\n        shared.initialIndex = shared.currentIndex = shared.lastDropTarget = shared.isContainerModel = null;\n      }\n\n      // is item currently placed in original container and original position?\n      function isInitialPlacement(target, s) {\n        var sibling = s || (shared.mirror ? shared.currentSibling : nextEl(shared.item));\n        return target === shared.source && sibling === shared.initialSibling;\n      }\n\n      // find valid drop container\n      function findDropTarget(elementBehindCursor, clientX, clientY) {\n        var target = elementBehindCursor;\n\n        while (target && !accepted()) {\n          target = target.parentElement;\n        }\n        return target;\n\n        function accepted() {\n          var accepts = false;\n\n          if (isContainer(target)) { // is droppable?\n\n            var immediate = getImmediateChild(target, elementBehindCursor),\n              reference = getReference(target, immediate, clientX, clientY),\n              initial = isInitialPlacement(target, reference);\n\n            accepts = initial || o.accepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex);\n\n            if (shared.targetContainer !== target) { // used for scroll issue\n              shared.targetContainer = target;\n            }\n          }\n          return accepts;\n        }\n      }\n\n      function drag(e) {\n        if (!shared.mirror) {\n          return;\n        }\n        e = e || window.event;\n\n        // update coordinates\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        // count mirror coordiates\n        var x = shared.clientX - shared.offsetX,\n          y = shared.clientY - shared.offsetY,\n          pageX,\n          pageY,\n          offsetBox;\n\n        // fill extra properties if boundingBox is used\n        if (o.boundingBox) {\n          pageX = getCoord('pageX', e);\n          pageY = getCoord('pageY', e);\n          offsetBox = getOffset(o.boundingBox);\n        }\n\n        if (!o.lockY) {\n          if (!o.boundingBox || (pageX > offsetBox.left + shared.offsetX && pageX < offsetBox.right + shared.offsetXr)) {\n            shared.mirror.style.left = x + 'px';\n          } else if (o.boundingBox) { // check again in case user scrolled the view\n            if (pageX < offsetBox.left + shared.offsetX) {\n              shared.mirror.style.left = shared.clientX - (pageX - offsetBox.left) + 'px';\n            } else {\n              shared.mirror.style.left = shared.clientX - shared.mirrorWidth - (pageX - offsetBox.right) + 'px';\n            }\n          }\n        }\n        if (!o.lockX) {\n          if (!o.boundingBox || (pageY > offsetBox.top + shared.offsetY && pageY < offsetBox.bottom + shared.offsetYb)) {\n            shared.mirror.style.top = y + 'px';\n          } else if (o.boundingBox) { // check again in case user scrolled the view\n            if (pageY < offsetBox.top + shared.offsetY) {\n              shared.mirror.style.top = shared.clientY - (pageY - offsetBox.top) + 'px';\n            } else {\n              shared.mirror.style.top = shared.clientY - shared.mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n            }\n          }\n        }\n\n        var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n          dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY),\n          changed = dropTarget !== shared.lastDropTarget;\n\n        if (elementBehindCursor !== shared.lastElementBehindCursor) {\n          fireEvent(elementBehindCursor, shared.dragOverEvents['dragularenter'], !!dropTarget);\n          if (shared.lastElementBehindCursor) {\n            fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents['dragularleave'], elementBehindCursor);\n          }\n          shared.lastElementBehindCursor = elementBehindCursor;\n        }\n\n        if (changed) {\n          out();\n          shared.lastDropTarget = dropTarget;\n          over();\n        }\n\n        // do not copy in same container\n        if (dropTarget === shared.source && o.copy) {\n          if (shared.item.parentElement) {\n            shared.item.parentElement.removeChild(shared.item);\n          }\n          return;\n        }\n\n        var reference,\n          immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n        if (immediate !== null) {\n          reference = getReference(dropTarget, immediate, shared.clientX, shared.clientY);\n        } else if (o.revertOnSpill === true && !o.copy) {\n          // the case that mirror is not over valid target and reverting is on and copy is off\n          reference = shared.initialSibling;\n          dropTarget = shared.source;\n        } else {\n          // the case that mirror is not over valid target and removing is on or copy is on\n          if (o.copy && shared.item.parentElement !== null) {\n            // remove item or copy of item\n            shared.item.parentElement.removeChild(shared.item);\n          }\n          return;\n        }\n        if (reference === null ||\n          reference !== shared.item &&\n          reference !== nextEl(shared.item) &&\n          reference !== shared.currentSibling) {\n          // moving item/copy to new container from previous one\n          shared.currentSibling = reference;\n\n          dropTarget.insertBefore(shared.item, reference); // if reference is null item is inserted at the end\n\n          if (o.scope) {\n            o.scope.$emit('shadow', shared.item, dropTarget);\n          }\n        }\n\n        function moved(type) {\n          if (o.scope) {\n            o.scope.$emit(type, shared.item, shared.lastDropTarget, shared.source);\n          }\n          if (o.removeOnSpill === true) {\n            type === 'over' ? spillOver() : spillOut();\n          }\n        }\n\n        function over() {\n          if (changed) {\n            moved('over');\n          }\n        }\n\n        function out() {\n          if (shared.lastDropTarget) {\n            moved('out');\n          }\n        }\n      }\n\n      function spillOver() {\n        rmClass(shared.item, o.classes.hide);\n      }\n\n      function spillOut() {\n        if (drake.dragging) {\n          addClass(shared.item, o.classes.hide);\n        }\n      }\n\n      function scrollContainer(e) {\n        if (shared.targetContainer) {\n          var before = shared.targetContainer.scrollTop;\n          shared.targetContainer.scrollTop += e.deltaY;\n          // block scroll of the document when container can be scrolled\n          if (before !== shared.targetContainer.scrollTop) {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n        }\n      }\n\n      function renderMirrorImage() {\n        if (shared.mirror) {\n          return;\n        }\n        var rect = shared.sourceItem.getBoundingClientRect();\n        shared.mirror = shared.sourceItem.cloneNode(true);\n        shared.mirrorWidth = rect.width;\n        shared.mirrorHeight = rect.height;\n        shared.mirror.style.width = getRectWidth(rect) + 'px';\n        shared.mirror.style.height = getRectHeight(rect) + 'px';\n        rmClass(shared.mirror, o.classes.transit);\n        addClass(shared.mirror, o.classes.mirror);\n        o.mirrorContainer.appendChild(shared.mirror);\n        regEvent(documentElement, 'on', 'mousemove', drag);\n        addClass(body, o.classes.unselectable);\n        regEvent(shared.mirror, 'on', 'wheel', scrollContainer);\n        if (o.scope) {\n          o.scope.$emit('cloned', shared.mirror, shared.sourceItem);\n        }\n      }\n\n      function removeMirrorImage() {\n        if (shared.mirror) {\n          rmClass(body, o.classes.unselectable);\n          regEvent(documentElement, 'off', 'mousemove', drag);\n          regEvent(shared.mirror, 'off', 'wheel', scrollContainer);\n          shared.mirror.parentElement.removeChild(shared.mirror);\n          shared.mirror = null;\n        }\n      }\n\n      function getImmediateChild(dropTarget, target) {\n        var immediate = target;\n        while (immediate !== dropTarget && immediate.parentElement !== dropTarget) {\n          immediate = immediate.parentElement;\n        }\n        if (immediate === documentElement) {\n          return null;\n        }\n        return immediate;\n      }\n\n      function getReference(dropTarget, target, x, y) {\n        var horizontal = o.direction === 'horizontal',\n          reference = target !== dropTarget ? inside() : outside();\n        return reference;\n\n        function outside() { // slower, but able to figure out any position\n          var len = dropTarget.children.length,\n          i, el, rect;\n          for (i = 0; i < len; i++) {\n            el = dropTarget.children[i];\n            rect = el.getBoundingClientRect();\n            if (horizontal && rect.left > x) {\n              return el;\n            }\n            if (!horizontal && rect.top > y) {\n              return el;\n            }\n          }\n          return null;\n        }\n\n        function inside() { // faster, but only available if dropped inside a child element\n          var rect = target.getBoundingClientRect();\n          if (horizontal) {\n            return resolve(x > rect.left + getRectWidth(rect) / 2);\n          }\n          return resolve(y > rect.top + getRectHeight(rect) / 2);\n        }\n\n        function resolve(after) {\n          return after ? nextEl(target) : target;\n        }\n      }\n\n      function getScroll(scrollProp, offsetProp) {\n        if (typeof window[offsetProp] !== 'undefined') {\n          return window[offsetProp];\n        }\n        if (documentElement.clientHeight) {\n          return documentElement[scrollProp];\n        }\n        return body[scrollProp];\n      }\n\n      function getOffset(el) {\n        var rect = el.getBoundingClientRect(),\n          scrollTop = getScroll('scrollTop', 'pageYOffset'),\n          scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n        return {\n          left: rect.left + scrollLeft,\n          right: rect.right + scrollLeft,\n          top: rect.top + scrollTop,\n          bottom: rect.bottom + scrollTop\n        };\n      }\n\n      function getElementBehindPoint(point, x, y) {\n        var p = point || {},\n          state = p.className,\n          el;\n        p.className += ' ' + o.classes.hide;\n        el = document.elementFromPoint(x, y);\n        p.className = state;\n        return el;\n      }\n    };\n\n  // clean common/shared objects\n  serviceFn.cleanEnviroment = function cleanEnviroment() {\n    shared.classesCache = {};\n    shared.containersModel = {};\n    shared.containers = {};\n    shared.mirror = undefined;\n  };\n\n  serviceFn.shared = shared;\n\n  return serviceFn;\n\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n\n  // HELPERS FUNCTIONS:\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function emptyObj() {\n    return {};\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = shared.classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      shared.classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n    return host[coord];\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e, extra) {\n    if (!target) {\n      return;\n    }\n    shared.extra = extra;\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n}]);\n\n},{\"./dragularModule\":2}]},{},[2]);\n"],"sourceRoot":"/source/"}