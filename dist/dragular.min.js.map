{"version":3,"sources":["dragular.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","undefined","options","dragular","containersModel","$eval","./dragularModule",2,"angular","dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","$rootScope","$timeout","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","$el","element","never","always","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","lookupClass","className","cached","_classesCache","lastIndex","RegExp","addClass","current","test","rmClass","replace","trim","hasClass","indexOf","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","domIndexOf","child","parent","Array","prototype","children","fireEvent","target","dispatchEvent","eventType","_mirror","containersNameSpaced","containersNameSpacedModel","initialContainers","proceedNameSpaces","_containers","nameSpace","push","apply","makeArray","all","isArray","iAll","newArray","removeContainers","applyAsync","changes","forEach","container","index","splice","_containersModel","isContainer","drake","containers","isContainerNameSpaced","hasOwnProperty","events","remove","documentElement","release","grab","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","destroy","_grabbed","preventDefault","window","event","which","metaKey","ctrlKey","item","context","canStart","end","start","direction","_item","parentElement","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","_offsetX","_offsetY","_clientX","_clientY","boundingBox","_offsetXr","_offsetYb","_copy","classes","transit","renderMirrorImage","style","drag","dragging","_isContainer","handle","invalid","source","moves","_itemModel","_sourceModel","manualStart","containerIndex","itemIndex","_initialIndex","_currentIndex","_targetModel","copy","_copyModel","cloneNode","scope","$emit","_source","_initialSibling","_currentSibling","invalidTarget","drop","ungrab","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","removeOnSpill","cancel","_targetContainer","dragOverClasses","_lastOverElem","_lastOverClass","isInitialPlacement","cleanup","itemModel","$applyAsync","removeChild","revert","reverts","arguments","revertOnSpill","initial","_lastTargetModel","moveInContainersModel","insertBefore","removeMirrorImage","_renderTimer","spillOut","_lastDropTarget","clientX","clientY","accepted","accepts","immediate","getImmediateChild","reference","getReference","overActive","overAccepts","overDeclines","moved","spillOver","over","changed","out","offsetBox","x","y","lockY","_mirrorWidth","lockX","_mirrorHeight","_lastElementBehindCursor","_dragEnterEvent","_dragLeaveEvent","referenceIndex","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","getBoundingClientRect","mirror","mirrorContainer","appendChild","body","unselectable","outside","len","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","document","elementFromPoint","defaultClasses","delay","extend","createEvent","initEvent","createEventObject"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.directive('dragular', ['dragularService', function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope[iAttrs.dragular] || tryJson(iAttrs.dragular);\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}]);\n\n},{\"./dragularModule\":2}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n\n\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n\n},{\"./dragularDirective.js\":1,\"./dragularService.js\":3}],3:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Module and Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\n/**\n * @ngInject\n */\n\ndragularModule.factory('dragularService', ['$rootScope', '$timeout', function dragula($rootScope, $timeout) {\n\n  var containersNameSpaced = {}, // name-spaced containers\n    containersNameSpacedModel = {}, // name-spaced containers models\n    _classesCache = {}, // classes lookup cache\n    _mirror; // mirror image\n\n  return function(initialContainers, options) {\n\n    if (arguments.length === 1 && !Array.isArray(initialContainers) && !angular.isElement(initialContainers) && !initialContainers[0]) {\n      // then containers are not provided, only options\n      options = initialContainers;\n      initialContainers = [];\n    }\n\n    var body = document.body,\n      documentElement = document.documentElement,\n      _source, // source container\n      _item, // item being dragged\n      _sourceModel, // source container model\n      _itemModel, // item-model being dragged\n      _targetModel, // target container model\n      _lastTargetModel, // last target container model\n      _lastDropTarget = null, // last container item was over\n      _offsetX, // reference x\n      _offsetY, // reference y\n      _offsetXr, // reference x right for boundingBox feature\n      _offsetYb, // reference y bottom for boundingBox feature\n      _clientX, // cache client x, init at grab, update at drag\n      _clientY, // cache client y, init at grab, update at drag\n      _mirrorWidth, // mirror width for boundingBox feature\n      _mirrorHeight, // mirror height for boundingBox feature\n      _initialSibling, // reference sibling when grabbed\n      _currentSibling, // reference sibling now\n      _initialIndex, // reference model index when grabbed\n      _currentIndex, // reference model index now\n      _lastOverElem, // last element behind the cursor (dragOverClasses feature)\n      _lastOverClass, // last overClass used (dragOverClasses feature)\n      _copy, // item used for copying\n      _copyModel, // item-model used for copying\n      _containers = {}, // containers managed by the drake\n      _containersModel = {}, // containers model\n      _renderTimer, // timer for setTimeout renderMirrorImage\n      _isContainer, // internal isContainer\n      _targetContainer, // droppable container under drag item\n      _dragEnterEvent, // drag enter event fired on element behind cursor\n      _dragLeaveEvent, // drag leave event fired on element behind cursor\n      _lastElementBehindCursor, // last element behind cursor\n      _grabbed, // holds mousedown context until first mousemove\n      defaultClasses = {\n        mirror: 'gu-mirror',\n        hide: 'gu-hide',\n        unselectable: 'gu-unselectable',\n        transit: 'gu-transit',\n        overActive: 'gu-over-active',\n        overAccepts: 'gu-over-accept',\n        overDeclines: 'gu-over-decline'\n      },\n      o = { // options\n        classes: defaultClasses,\n        containers: false,\n        moves: always,\n        accepts: always,\n        isContainer: never,\n        copy: false,\n        delay: false,\n        invalid: invalidTarget,\n        revertOnSpill: false,\n        removeOnSpill: false,\n        dragOverClasses: false,\n        lockX: false,\n        lockY: false,\n        boundingBox: false,\n        containersModel: false\n      };\n\n    if (!isElement(o.boundingBox)) {\n      o.boundingBox = null;\n    }\n\n    if (options && options.classes) {\n      angular.extend(defaultClasses, options.classes);\n      angular.extend(options.classes, defaultClasses);\n    }\n\n    angular.extend(o, options);\n\n    if (!o.mirrorContainer) {\n      o.mirrorContainer = document.body;\n    }\n\n    // get initial containers from options, argument or fall back to empty array (containers can be added later)\n    initialContainers = o.containers || (initialContainers ? makeArray(initialContainers) : []);\n    if (o.containers) {\n      // make array from o.containers\n      initialContainers = makeArray(initialContainers);\n    }\n    if (o.containersModel) {\n      o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n    }\n\n    function proceedNameSpaces(_containers, containersNameSpaced, nameSpace, initialContainers) {\n      if (!containersNameSpaced[nameSpace]) {\n        containersNameSpaced[nameSpace] = [];\n      }\n      Array.prototype.push.apply(containersNameSpaced[nameSpace], initialContainers);\n      _containers[nameSpace] = containersNameSpaced[nameSpace];\n    }\n\n    // feed namespaced containers groups and optionaly shadow it by models\n    if (o.nameSpace) {\n      if (!Array.isArray(o.nameSpace)) {\n        o.nameSpace = [o.nameSpace];\n      }\n      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n        proceedNameSpaces(_containers, containersNameSpaced, nameSpace, initialContainers);\n        if (o.containersModel) {\n          proceedNameSpaces(_containersModel, containersNameSpacedModel, nameSpace, o.containersModel);\n        }\n      });\n      _isContainer = isContainerNameSpaced;\n    } else {\n      // default (not using nameSpaces)\n      _containers = initialContainers;\n      _isContainer = isContainer;\n      if (o.containersModel) {\n        _containersModel = o.containersModel;\n      }\n    }\n\n    //register events\n    events();\n\n    if (document.createEvent) {\n      _dragEnterEvent = document.createEvent('HTMLEvents');\n      _dragEnterEvent.initEvent('dragularenter', true, true);\n      _dragLeaveEvent = document.createEvent('HTMLEvents');\n      _dragLeaveEvent.initEvent('dragularleave', true, true);\n    } else {\n      _dragEnterEvent = document.createEventObject();\n      _dragEnterEvent.eventType = 'dragularenter';\n      _dragLeaveEvent = document.createEventObject();\n      _dragLeaveEvent.eventType = 'dragularleave';\n    }\n\n    var drake = {\n      containers: _containers,\n      containersModel: _containersModel,\n      start: manualStart,\n      end: end,\n      cancel: cancel,\n      remove: remove,\n      destroy: destroy,\n      dragging: false\n    };\n\n    return drake;\n\n    // make array from array-like objects or from single element\n    function makeArray(all) {\n      if (Array.isArray(all)) {\n        return all;\n      }\n      if (all.length) { // is array-like\n        var iAll = all.length,\n          newArray = [],\n          i;\n        for (i = 0; i < iAll; i++) {\n          newArray.push(all[i]);\n        }\n        return newArray;\n      } else { // is one element\n        return [all];\n      }\n    }\n\n    // add or remove containers - deprecated\n    function removeContainers(all) {\n      $rootScope.applyAsync(function applyDestroyed() {\n        var changes = Array.isArray(all) ? all : makeArray(all);\n        changes.forEach(function forEachContainer(container) {\n          if (o.nameSpace) {\n            angular.forEach(o.nameSpace, function addRemoveNamespaced(nameSpace) {\n              var index;\n              index = _containers[nameSpace].indexOf(container);\n              _containers[nameSpace].splice(index, 1);\n              if (o.containersModel) {\n                _containersModel[nameSpace].splice(index, 1);\n              }\n            });\n          } else {\n            _containers.splice(_containers.indexOf(container), 1);\n          }\n        });\n      });\n    }\n\n    function isContainer(el) {\n      return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n    }\n\n    function isContainerNameSpaced(el) {\n      var nameSpace;\n      for (nameSpace in drake.containers) {\n        if (drake.containers.hasOwnProperty(nameSpace) && drake.containers[nameSpace].indexOf(el) !== -1) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function events(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(documentElement, op, 'mouseup', release);\n\n      initialContainers.forEach(function addMouseDown(container) {\n        regEvent(container, 'on', 'mousedown', grab);\n      });\n    }\n\n    function eventualMovements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(documentElement, op, 'mousemove', startBecauseMouseMoved);\n    }\n\n    function movements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(documentElement, op, 'selectstart', preventGrabbed); // IE8\n      regEvent(documentElement, op, 'click', preventGrabbed);\n    }\n\n    function destroy() {\n      events(true);\n      removeContainers(initialContainers);\n      release({});\n    }\n\n    function preventGrabbed(e) {\n      if (_grabbed) {\n        e.preventDefault();\n      }\n    }\n\n    function grab(e) {\n      e = e || window.event;\n\n      // filter some odd situations\n      if ((e.which !== 0 && e.which !== 1) || e.metaKey || e.ctrlKey) {\n        return; // we only care about honest-to-god left clicks and touch events\n      }\n\n      var item = e.target,\n        context = canStart(item);\n      if (!context) {\n        return;\n      }\n\n      _grabbed = context;\n      eventualMovements();\n      if (e.type === 'mousedown') {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n\n    function startBecauseMouseMoved(e) {\n      eventualMovements(true); // remove mousemove listener\n      movements();\n      end();\n      start(_grabbed);\n\n      // automaticly detect direction of elements if not set in options\n      if (!o.direction) {\n        var parent = _item.parentElement,\n          parentHeight = parent.offsetHeight,\n          parentWidth = parent.offsetWidth,\n          childHeight = _item.clientHeight,\n          childWidth = _item.clientWidth;\n        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n      }\n\n      // get initial coordinates, used to render _mirror for first time\n      var offset = getOffset(_item);\n      _offsetX = getCoord('pageX', e) - offset.left;\n      _offsetY = getCoord('pageY', e) - offset.top;\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // limiting area of _mirror movement, get initial coordinates\n      if (o.boundingBox) {\n        _offsetXr = getCoord('pageX', e) - offset.right;\n        _offsetYb = getCoord('pageY', e) - offset.bottom;\n      }\n\n      e.preventDefault();\n\n      addClass(_copy || _item, o.classes.transit);\n      renderMirrorImage();\n      // initial position\n      _mirror.style.left = _clientX - _offsetX + 'px';\n      _mirror.style.top = _clientY - _offsetY + 'px';\n\n      drag(e);\n    }\n\n\n    function canStart(item) {\n      if (drake.dragging && _mirror) {\n        return; // already dragging\n      }\n\n      if (_isContainer(item)) {\n        return; // don't drag container itself\n      }\n\n      var handle = item;\n\n      while (item.parentElement && !_isContainer(item.parentElement)) {\n        // break loop if user tries to drag item which is considered invalid handle\n        if (o.invalid(item, handle)) {\n          return;\n        }\n        item = item.parentElement; // drag target should be immediate child of container\n        if (!item) {\n          return;\n        }\n      }\n\n      var source = item.parentElement;\n      if (!source) {\n        return;\n      }\n      if (!source || o.invalid(item, handle) || !o.moves(item, source, handle, _itemModel, _sourceModel)) { // is movable\n        return;\n      }\n\n      return {\n        item: item,\n        source: source\n      };\n    }\n\n    function manualStart(item) {\n      var context = canStart(item);\n      if (context) {\n        start(context);\n      }\n    }\n\n    function start(context) {\n\n      // prepare models operations\n      if (o.containersModel) {\n        var containerIndex = initialContainers.indexOf(context.source),\n          itemIndex = domIndexOf(context.item, context.source);\n\n        _initialIndex = _currentIndex = itemIndex;\n        _sourceModel = o.containersModel[containerIndex];\n        _targetModel = _sourceModel;\n        _itemModel = _sourceModel[itemIndex];\n        if (o.copy) {\n          _copyModel = angular.copy(_itemModel);\n        }\n      }\n\n      if (o.copy) {\n        _copy = context.item.cloneNode(true);\n        if (o.scope) {\n          o.scope.$emit('cloned', _copy, context.item, _copyModel, _itemModel);\n        }\n      }\n\n      _source = context.source;\n      _item = context.item;\n      _initialSibling = _currentSibling = nextEl(context.item);\n\n      drake.dragging = true;\n      if (o.scope) {\n        o.scope.$emit('drag', _item, _source);\n      }\n\n      return true;\n    }\n\n    function invalidTarget() {\n      return false;\n    }\n\n    function end() {\n      if (!drake.dragging) {\n        return;\n      }\n      var item = _copy || _item;\n      drop(item, item.parentElement);\n    }\n\n    function ungrab() {\n      _grabbed = false;\n      eventualMovements(true);\n      movements(true);\n    }\n\n    function release(e) {\n      ungrab();\n      if (!drake.dragging) {\n        return;\n      }\n      e = e || window.event;\n\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      var item = _copy || _item,\n        elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY);\n\n      if (dropTarget && (o.copy === false || dropTarget !== _source)) {\n        // found valid target and (is not copy case or target is not initial container)\n        drop(item, dropTarget);\n      } else if (o.removeOnSpill) {\n        remove();\n      } else {\n        cancel();\n      }\n\n      // after release there is no container hovered\n      _targetContainer = null;\n\n      // remove classes if used\n      if (o.dragOverClasses && _lastOverElem) {\n        rmClass(_lastOverElem, _lastOverClass);\n        _lastOverElem = null;\n      }\n\n      if (o.scope) {\n        o.scope.$emit('release', item, _source);\n      }\n    }\n\n    function drop(item, target) {\n      if (o.scope && isInitialPlacement(target)) {\n        o.scope.$emit('cancel', item, _source, _copyModel || _itemModel, _sourceModel, _targetModel);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, target, _source, _copyModel || _itemModel, _sourceModel, _targetModel);\n      }\n      cleanup();\n    }\n\n    function remove() {\n      if (!drake.dragging) {\n        return;\n      }\n      var item = _copy || _item,\n        parent = item.parentElement,\n        itemModel;\n\n      if (!o.containersModel) {\n        if (parent) {\n          parent.removeChild(item);\n        }\n      } else {\n        itemModel = _copyModel || _itemModel;\n        $rootScope.$applyAsync(function removeModel() {\n          _targetModel.splice(_targetModel.indexOf(itemModel), 1);\n        });\n      }\n\n      if (o.scope) {\n        o.scope.$emit(o.copy ? 'cancel' : 'remove', item, parent, itemModel, _sourceModel, _targetModel);\n      }\n      cleanup();\n    }\n\n    function cancel(revert) {\n      if (!drake.dragging) {\n        return;\n      }\n      var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n        item = _copy || _item,\n        parent = item.parentElement;\n\n      if (parent === _source && o.copy) {\n        console.log('!!!!!!!!!!!!!!!!! I think this is never possible because copy cannot be placed into source');\n        if (!o.containersModel) {\n          parent.removeChild(_copy);\n        } else {\n          _targetModel.splice(_targetModel.indexOf(_copyModel), 1, _copyModel);\n        }\n      }\n\n      var initial = isInitialPlacement(parent);\n      if (initial === false && o.copy === false && reverts) {\n        if (!o.containersModel) {\n          _source.insertBefore(item, _initialSibling);\n        } else {\n          _lastTargetModel = _targetModel;\n          _targetModel = _sourceModel;\n          // move back to initial placement\n          moveInContainersModel(_initialIndex);\n        }\n      }\n\n      if (o.scope && (initial || reverts)) {\n        o.scope.$emit('cancel', item, _source);\n      } else if (o.scope) {\n        o.scope.$emit('drop', item, parent, _source);\n      }\n\n      cleanup();\n    }\n\n    function cleanup() {\n      ungrab();\n      var item = _copy || _item;\n      removeMirrorImage();\n\n      if (item) {\n        rmClass(item, o.classes.transit);\n      }\n\n      // cancel timer\n      if (_renderTimer) {\n        $timeout.cancel(_renderTimer);\n      }\n\n      drake.dragging = false;\n\n      if (o.removeOnSpill === true) {\n        spillOut(item);\n      }\n\n      if (o.scope) {\n        o.scope.$emit('out', item, _lastDropTarget, _source);\n        o.scope.$emit('dragend', item);\n      }\n\n      _source = _item = _copy = _initialSibling = _currentSibling = _sourceModel = null;\n      _itemModel = _copyModel = _initialIndex = _currentIndex = _renderTimer = _lastDropTarget = null;\n    }\n\n    // is item currently placed in original container and original position?\n    function isInitialPlacement(target, s) {\n      var sibling = s || (_mirror ? _currentSibling : nextEl(_item || _copy));\n      return target === _source && sibling === _initialSibling;\n    }\n\n    // find valid drop container\n    function findDropTarget(elementBehindCursor, clientX, clientY) {\n      var target = elementBehindCursor;\n\n      while (target && !accepted()) {\n        target = target.parentElement;\n      }\n      return target;\n\n      function accepted() {\n        var accepts = false;\n\n        if (_isContainer(target)) { // is droppable?\n          _targetContainer = target;\n\n          var immediate = getImmediateChild(target, elementBehindCursor),\n            reference = getReference(target, immediate, clientX, clientY),\n            initial = isInitialPlacement(target, reference);\n          accepts = initial ? true : o.accepts(_item, target, _source, reference, _itemModel, _sourceModel);\n\n          if (accepts && o.containersModel) {\n            _lastTargetModel = _targetModel;\n            if (!o.nameSpace) {\n              _targetModel = _containersModel[drake.containers.indexOf(target)];\n            } else {\n              for (var nameSpace in drake.containers) {\n                if (drake.containers.hasOwnProperty(nameSpace) && drake.containers[nameSpace].indexOf(target) !== -1) {\n                  _lastTargetModel = _targetModel;\n                  _targetModel = _containersModel[nameSpace][drake.containers[nameSpace].indexOf(target)];\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // add class if element is enabled for it and it has not already the class\n        if (o.dragOverClasses &&\n          hasClass(target, o.classes.overActive) &&\n          target !== _lastOverElem) {\n\n          if (_lastOverElem) { // clear from previous\n            rmClass(_lastOverElem, _lastOverClass);\n          }\n\n          _lastOverClass = accepts ? o.classes.overAccepts : o.classes.overDeclines;\n          addClass(target, _lastOverClass);\n          _lastOverElem = target;\n        }\n\n        return accepts;\n      }\n    }\n\n    function drag(e) {\n      if (!_mirror) {\n        return;\n      }\n      e = e || window.event;\n\n      // update coordinates\n      _clientX = getCoord('clientX', e);\n      _clientY = getCoord('clientY', e);\n\n      // count mirror coordiates\n      var x = _clientX - _offsetX,\n        y = _clientY - _offsetY,\n        pageX,\n        pageY,\n        offsetBox;\n\n      // fill extra properties if boundingBox is used\n      if (o.boundingBox) {\n        pageX = getCoord('pageX', e);\n        pageY = getCoord('pageY', e);\n        offsetBox = getOffset(o.boundingBox);\n      }\n\n      if (!o.lockY) {\n        if (!o.boundingBox || (pageX > offsetBox.left + _offsetX && pageX < offsetBox.right + _offsetXr)) {\n          _mirror.style.left = x + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageX < offsetBox.left + _offsetX) {\n            _mirror.style.left = _clientX - (pageX - offsetBox.left) + 'px';\n          } else {\n            _mirror.style.left = _clientX - _mirrorWidth - (pageX - offsetBox.right) + 'px';\n          }\n        }\n      }\n      if (!o.lockX) {\n        if (!o.boundingBox || (pageY > offsetBox.top + _offsetY && pageY < offsetBox.bottom + _offsetYb)) {\n          _mirror.style.top = y + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageY < offsetBox.top + _offsetY) {\n            _mirror.style.top = _clientY - (pageY - offsetBox.top) + 'px';\n          } else {\n            _mirror.style.top = _clientY - _mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n          }\n        }\n      }\n\n      var item = _copy || _item,\n        elementBehindCursor = getElementBehindPoint(_mirror, _clientX, _clientY),\n        dropTarget = findDropTarget(elementBehindCursor, _clientX, _clientY),\n        changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n\n      if (elementBehindCursor !== _lastElementBehindCursor) {\n        fireEvent(elementBehindCursor, _dragEnterEvent);\n        if (_lastElementBehindCursor) {\n          fireEvent(_lastElementBehindCursor, _dragLeaveEvent);\n        }\n        _lastElementBehindCursor = elementBehindCursor;\n      }\n\n      if (changed || dropTarget === null) {\n        if (o.scope) {\n          out();\n          _lastDropTarget = dropTarget;\n          over();\n        } else {\n          _lastDropTarget = dropTarget;\n        }\n      }\n\n      // do not copy in same container\n      if (dropTarget === _source && o.copy) {\n        if (!o.containersModel && item.parentElement) {\n          item.parentElement.removeChild(item);\n        } else if (o.containersModel && _lastTargetModel.indexOf(_copyModel) !== -1) {\n          $rootScope.$applyAsync(function removeCopyFromLastContainer() {\n            console.log(_lastTargetModel.indexOf(_copyModel), _currentIndex);\n            _lastTargetModel.splice(_lastTargetModel.indexOf(_copyModel), 1);\n          });\n        }\n        return;\n      }\n\n      var reference,\n        immediate = getImmediateChild(dropTarget, elementBehindCursor),\n        referenceIndex;\n\n      if (immediate !== null) {\n        reference = getReference(dropTarget, immediate, _clientX, _clientY);\n        if (o.containersModel) {\n          if (reference) { // reference is null if drag is over last element\n            referenceIndex = domIndexOf(reference, dropTarget);\n          } else {\n            referenceIndex = null;\n          }\n        }\n      } else if (o.revertOnSpill === true && !o.copy) {\n        // the case that mirror is not over valid target and reverting is on and copy is off\n        reference = _initialSibling;\n        dropTarget = _source;\n\n        // getting model intitial properties into current\n        if (o.containersModel) {\n          referenceIndex = _initialIndex;\n          _lastTargetModel = _targetModel;\n          _targetModel = _sourceModel;\n        }\n      } else {\n        // the case that mirror is not over valid target and removing is on or copy is on\n        if (o.copy && item.parentElement !== null) {\n          // remove item or copy of item\n          if (!o.containersModel) {\n            item.parentElement.removeChild(item);\n          } else if (_targetModel !== _sourceModel && _targetModel.indexOf(_copyModel || _itemModel)) {\n            console.log('removeOnSpill', o.copy, _targetModel !== _sourceModel, _targetModel, _sourceModel);\n            $rootScope.$applyAsync(function removeOnSpillOrRemoveCopy() {\n              _targetModel.splice(referenceIndex, 1);\n            });\n          }\n        }\n        return;\n      }\n      if (reference === null ||\n        reference !== item &&\n        reference !== nextEl(item) &&\n        reference !== _currentSibling) {\n        // moving item/copy to new container from previous one\n        _currentSibling = reference;\n\n        if (!o.containersModel) {\n          dropTarget.insertBefore(item, reference); // if reference is null item is inserted at the end\n        } else {\n          moveInContainersModel(referenceIndex);\n        }\n\n        if (o.scope) {\n          o.scope.$emit('shadow', item, dropTarget);\n        }\n      }\n\n      function moved(type) {\n        if (o.scope) {\n          o.scope.$emit(type, item, _lastDropTarget, _source);\n        }\n        if (o.removeOnSpill === true) {\n          type === 'over' ? spillOver(item) : spillOut(item);\n        }\n      }\n\n      function over() {\n        if (changed) {\n          moved('over');\n        }\n      }\n\n      function out() {\n        if (_lastDropTarget) {\n          moved('out');\n        }\n      }\n    }\n\n    function spillOver(el) {\n      rmClass(el, o.classes.hide);\n    }\n\n    function spillOut(el) {\n      if (drake.dragging) {\n        addClass(el, o.classes.hide);\n      }\n    }\n\n    function moveInContainersModel(referenceIndex) {\n      $rootScope.$applyAsync(function applyMoveBetweenContainers() {\n        if (_lastTargetModel === _targetModel) {\n          if (referenceIndex === null) {\n            referenceIndex = _targetModel.length;\n          }\n          var index = referenceIndex > _currentIndex ? referenceIndex - 1 : referenceIndex;\n          _targetModel.splice(index, 0, _lastTargetModel.splice(_currentIndex, 1)[0]);\n          _currentIndex = index;\n        } else {\n          if (referenceIndex === null) {\n            referenceIndex = _targetModel.length - 1;\n          }\n          if (!o.copy || _lastTargetModel !== _sourceModel) { // dont remove original from source while copying\n            _lastTargetModel.splice(_currentIndex, 1);\n          }\n          if (!o.copy || _targetModel.indexOf(_copyModel) === -1) { // dont place copy twice in one drag\n            _targetModel.splice(referenceIndex, 0, _copyModel || _itemModel);\n            _currentIndex = referenceIndex;\n          }\n        }\n      });\n    }\n\n    function scrollContainer(e) {\n      if (_targetContainer) {\n        var before = _targetContainer.scrollTop;\n        _targetContainer.scrollTop += e.deltaY;\n        // block scroll of the document when container can be scrolled\n        if (before !== _targetContainer.scrollTop) {\n          e.stopPropagation();\n          e.preventDefault();\n        }\n      }\n    }\n\n    function renderMirrorImage() {\n      if (_mirror) {\n        return;\n      }\n      var rect = _item.getBoundingClientRect();\n      _mirror = _item.cloneNode(true);\n      _mirrorWidth = rect.width;\n      _mirrorHeight = rect.height;\n      _mirror.style.width = getRectWidth(rect) + 'px';\n      _mirror.style.height = getRectHeight(rect) + 'px';\n      rmClass(_mirror, o.classes.transit);\n      addClass(_mirror, o.classes.mirror);\n      o.mirrorContainer.appendChild(_mirror);\n      regEvent(documentElement, 'on', 'mousemove', drag);\n      addClass(body, o.classes.unselectable);\n      regEvent(_mirror, 'on', 'wheel', scrollContainer);\n      if (o.scope) {\n        o.scope.$emit('cloned', _mirror, _item);\n      }\n    }\n\n    function removeMirrorImage() {\n      if (_mirror) {\n        rmClass(body, o.classes.unselectable);\n        regEvent(documentElement, 'off', 'mousemove', drag);\n        regEvent(_mirror, 'off', 'wheel', scrollContainer);\n        _mirror.parentElement.removeChild(_mirror);\n        _mirror = null;\n      }\n    }\n\n    function getImmediateChild(dropTarget, target) {\n      var immediate = target;\n      while (immediate !== dropTarget && immediate.parentElement !== dropTarget) {\n        immediate = immediate.parentElement;\n      }\n      if (immediate === documentElement) {\n        return null;\n      }\n      return immediate;\n    }\n\n    function getReference(dropTarget, target, x, y) {\n      var horizontal = o.direction === 'horizontal';\n      var reference = target !== dropTarget ? inside() : outside();\n      return reference;\n\n      function outside() { // slower, but able to figure out any position\n        var len = dropTarget.children.length;\n        var i;\n        var el;\n        var rect;\n        for (i = 0; i < len; i++) {\n          el = dropTarget.children[i];\n          rect = el.getBoundingClientRect();\n          if (horizontal && rect.left > x) {\n            return el;\n          }\n          if (!horizontal && rect.top > y) {\n            return el;\n          }\n        }\n        return null;\n      }\n\n      function inside() { // faster, but only available if dropped inside a child element\n        var rect = target.getBoundingClientRect();\n        if (horizontal) {\n          return resolve(x > rect.left + getRectWidth(rect) / 2);\n        }\n        return resolve(y > rect.top + getRectHeight(rect) / 2);\n      }\n\n      function resolve(after) {\n        return after ? nextEl(target) : target;\n      }\n    }\n\n    function getScroll(scrollProp, offsetProp) {\n      if (typeof window[offsetProp] !== 'undefined') {\n        return window[offsetProp];\n      }\n      if (documentElement.clientHeight) {\n        return documentElement[scrollProp];\n      }\n      return body[scrollProp];\n    }\n\n    function getOffset(el) {\n      var rect = el.getBoundingClientRect(),\n        scrollTop = getScroll('scrollTop', 'pageYOffset'),\n        scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n      return {\n        left: rect.left + scrollLeft,\n        right: rect.right + scrollLeft,\n        top: rect.top + scrollTop,\n        bottom: rect.bottom + scrollTop\n      };\n    }\n\n    function getElementBehindPoint(point, x, y) {\n      var p = point || {},\n        state = p.className,\n        el;\n      p.className += ' ' + o.classes.hide;\n      el = document.elementFromPoint(x, y);\n      p.className = state;\n      return el;\n    }\n  };\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = _classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      _classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function hasClass(el, className) {\n    return (' ' + el.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n    return host[coord];\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e) {\n    if (!target) {\n      return;\n    }\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n}]);\n\n},{\"./dragularModule\":2}]},{},[2]);\n"],"sourceRoot":"/source/"}